diff --git a/meta_agent/src/bin/planner_cli.rs b/meta_agent/src/bin/planner_cli.rs
new file mode 100644
index 0000000..20f949e
--- /dev/null
+++ b/meta_agent/src/bin/planner_cli.rs
@@ -0,0 +1,32 @@
+// Minimal CLI entrypoint for the MVP planner
+
+use meta_agent::planner::cli::run_cli;
+use rig::providers::anthropic::Client as Anthropic;
+use meta_agent::llm::LLMClient as _; // bring `.boxed()` into scope
+
+#[tokio::main]
+async fn main() -> eyre::Result<()> {
+    // Non-interactive input via env var PLANNER_INPUT; fallback to prompt
+    let model = std::env::var("PLANNER_MODEL").unwrap_or_else(|_| "claude-3-5-sonnet-latest".to_string());
+    let llm_api_key = std::env::var("ANTHROPIC_API_KEY").ok();
+    let input = std::env::var("PLANNER_INPUT").ok();
+
+    let anthropic_base = std::env::var("ANTHROPIC_BASE_URL").unwrap_or_else(|_| "https://api.anthropic.com".to_string());
+    let anthropic_version = std::env::var("ANTHROPIC_VERSION").unwrap_or_else(|_| "2023-06-01".to_string());
+    let llm = llm_api_key.as_ref().map(|key| {
+        Anthropic::new(key.as_str(), anthropic_base.as_str(), None, anthropic_version.as_str()).boxed()
+    });
+
+    if let Some(input) = input {
+        // Run non-interactively
+        // Reuse run_cli path by setting stdin to input when provided
+        println!("Input: {}", input);
+        // For now, call run_cli which asks stdin; a dedicated non-interactive path can be added later
+        run_cli(llm, model).await
+    } else {
+        // Interactive
+        run_cli(llm, model).await
+    }
+}
+
+
diff --git a/meta_agent/src/planner/cli.rs b/meta_agent/src/planner/cli.rs
new file mode 100644
index 0000000..60b1875
--- /dev/null
+++ b/meta_agent/src/planner/cli.rs
@@ -0,0 +1,102 @@
+//! Simple CLI demo for the MVP planner
+
+use crate::planner::{
+    llm::LLMPlanner,
+    handler::{Command, Event, Handler},
+    Planner,
+};
+use crate::llm::LLMClientDyn;
+use eyre::Result;
+use std::io::{self, Write};
+
+/// Run the planner CLI
+pub async fn run_cli(llm: Option<Box<dyn LLMClientDyn>>, model: String) -> Result<()> {
+    println!("ðŸ¤– Event-Sourced LLM Planner (MVP)");
+    println!("Type your request and press Enter:");
+    println!();
+    
+    // Read user input (support non-interactive via PLANNER_INPUT)
+    let input_env = std::env::var("PLANNER_INPUT").ok();
+    let input_owned: String;
+    let input = if let Some(val) = input_env {
+        input_owned = val;
+        input_owned.trim()
+    } else {
+        print!("> ");
+        io::stdout().flush()?;
+        let mut input_buf = String::new();
+        io::stdin().read_line(&mut input_buf)?;
+        input_owned = input_buf;
+        input_owned.trim()
+    };
+    
+    if input.is_empty() {
+        println!("No input provided.");
+        return Ok(());
+    }
+    
+    // Process with LLM or fallback
+    let events = if let Some(llm) = llm {
+        println!("\nðŸ§  Using LLM to parse tasks...");
+        let planner = LLMPlanner::new(llm, model);
+        let tasks = planner.parse_tasks(input).await?;
+        
+        println!("\nðŸ“‹ Parsed {} task(s):", tasks.len());
+        for task in &tasks {
+            println!("  #{}: {} [{:?}]", task.id, task.description, task.kind);
+        }
+        
+        vec![Event::TasksPlanned {
+            tasks: tasks.into_iter().map(|t| t.into()).collect(),
+        }]
+    } else {
+        println!("\nâš ï¸  No LLM configured, using basic fallback...");
+        let mut planner = Planner::new();
+        planner.process(Command::Initialize {
+            user_input: input.to_string(),
+            attachments: vec![],
+        })?
+    };
+    
+    // Save to DabGent MQ if feature enabled
+    #[cfg(feature = "mq")]
+    {
+        use dabgent_mq::db::{EventStore, Metadata, sqlite::SqliteStore};
+        use uuid::Uuid;
+        
+        println!("\nðŸ’¾ Saving to DabGent MQ...");
+        let pool = sqlx::sqlite::SqlitePoolOptions::new()
+            .max_connections(1)
+            .connect("sqlite::memory:")
+            .await?;
+        let store = SqliteStore::new(pool);
+        store.migrate().await;
+        
+        let session_id = Uuid::new_v4().to_string();
+        for event in &events {
+            store.push_event("planner", &session_id, event, &Metadata::default()).await?;
+        }
+        
+        println!("âœ… Events saved to session: {}", session_id);
+    }
+    
+    #[cfg(not(feature = "mq"))]
+    {
+        println!("\nâš ï¸  DabGent MQ not enabled (compile with --features mq)");
+    }
+    
+    println!("\nâœ¨ Done!");
+    Ok(())
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[tokio::test]
+    async fn test_cli_basic() {
+        // Just verify it compiles and can be called
+        // Real CLI testing would need mock stdin/stdout
+        assert!(true);
+    }
+}
diff --git a/meta_agent/src/planner/handler.rs b/meta_agent/src/planner/handler.rs
new file mode 100644
index 0000000..1873fbf
--- /dev/null
+++ b/meta_agent/src/planner/handler.rs
@@ -0,0 +1,551 @@
+use crate::planner::types::{ExecutorEvent, PlannerCmd, PlannerState, NodeKind, TaskStatus, Task};
+use serde::{Deserialize, Serialize};
+
+/// Core handler trait for event-sourced components
+pub trait Handler {
+    type Command;
+    type Event;
+    type Error;
+
+    /// Process a command and emit events
+    fn process(&mut self, command: Self::Command) -> Result<Vec<Self::Event>, Self::Error>;
+    
+    /// Rebuild state from events
+    fn fold(events: &[Self::Event]) -> Self;
+}
+
+/// Commands that the planner can process
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum Command {
+    /// Initialize planner with user input
+    Initialize {
+        user_input: String,
+        attachments: Vec<crate::planner::types::Attachment>,
+    },
+    /// Process an event from the executor
+    HandleExecutorEvent(ExecutorEvent),
+    /// Continue planning after a pause
+    Continue,
+    /// Compact context to manage token limits
+    CompactContext {
+        max_tokens: usize,
+    },
+}
+
+/// Events emitted by the planner
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum Event {
+    /// Tasks were planned
+    TasksPlanned {
+        tasks: Vec<TaskPlan>,
+    },
+    /// A task was dispatched for execution
+    TaskDispatched {
+        task_id: u64,
+        command: PlannerCmd,
+    },
+    /// Task status was updated
+    TaskStatusUpdated {
+        task_id: u64,
+        status: TaskStatus,
+        result: Option<String>,
+    },
+    /// Clarification was requested
+    ClarificationRequested {
+        task_id: u64,
+        question: String,
+    },
+    /// Clarification was received
+    ClarificationReceived {
+        task_id: u64,
+        answer: String,
+    },
+    /// Context was compacted
+    ContextCompacted {
+        summary: String,
+        removed_task_ids: Vec<u64>,
+    },
+    /// Planning completed
+    PlanningCompleted {
+        summary: String,
+    },
+}
+
+/// Task plan data for the TasksPlanned event
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct TaskPlan {
+    pub id: u64,
+    pub description: String,
+    pub kind: NodeKind,
+    pub attachments: Vec<crate::planner::types::Attachment>,
+}
+
+/// Error types for planner operations (MVP: simplified)
+#[derive(Debug, thiserror::Error)]
+pub enum PlannerError {
+    #[error("Invalid command: {0}")]
+    InvalidCommand(String),
+    
+    #[error("Task not found: {0}")]
+    TaskNotFound(u64),
+    
+    #[error("External error: {0}")]
+    ExternalError(String),
+}
+
+/// Event-sourced planner implementation
+pub struct Planner {
+    /// Current state
+    state: PlannerState,
+    /// Event history (for debugging/audit)
+    event_log: Vec<Event>,
+}
+
+impl Planner {
+    /// Create a new planner instance
+    pub fn new() -> Self {
+        Self {
+            state: PlannerState::default(),
+            event_log: Vec::new(),
+        }
+    }
+
+    /// Get the current state (for inspection/debugging)
+    pub fn state(&self) -> &PlannerState {
+        &self.state
+    }
+
+    /// Get event history (for debugging/audit)
+    pub fn events(&self) -> &[Event] {
+        &self.event_log
+    }
+
+    /// Apply an event to update state
+    fn apply_event(&mut self, event: &Event) {
+        match event {
+            Event::TasksPlanned { tasks } => {
+                for plan in tasks {
+                    let mut task = Task::new(plan.id, plan.description.clone(), plan.kind);
+                    task.attachments = plan.attachments.clone();
+                    self.state.tasks.push(task);
+                    if plan.id >= self.state.next_id {
+                        self.state.next_id = plan.id + 1;
+                    }
+                }
+            }
+            
+            Event::TaskDispatched { task_id, .. } => {
+                self.state.mark_dispatched(*task_id);
+                if let Some(task) = self.state.get_task_mut(*task_id) {
+                    task.update_status(TaskStatus::Running);
+                }
+            }
+            
+            Event::TaskStatusUpdated { task_id, status, .. } => {
+                if let Some(task) = self.state.get_task_mut(*task_id) {
+                    task.update_status(*status);
+                }
+                
+                // Advance cursor if current task completed
+                if matches!(status, TaskStatus::Completed | TaskStatus::Failed) {
+                    if self.state.cursor < self.state.tasks.len() 
+                        && self.state.tasks[self.state.cursor].id == *task_id {
+                        self.state.advance_cursor();
+                    }
+                }
+            }
+            
+            Event::ClarificationRequested { task_id, .. } => {
+                self.state.set_clarification(*task_id);
+                if let Some(task) = self.state.get_task_mut(*task_id) {
+                    task.update_status(TaskStatus::NeedsClarification);
+                }
+            }
+            
+            Event::ClarificationReceived { task_id, .. } => {
+                self.state.clear_clarification();
+                if let Some(task) = self.state.get_task_mut(*task_id) {
+                    task.update_status(TaskStatus::Planned);
+                }
+            }
+            
+            Event::ContextCompacted { summary, removed_task_ids } => {
+                self.state.context_summary = summary.clone();
+                self.state.tasks.retain(|t| !removed_task_ids.contains(&t.id));
+            }
+            
+            Event::PlanningCompleted { .. } => {
+                // Mark all remaining tasks as completed
+                for task in &mut self.state.tasks {
+                    if task.status == TaskStatus::Planned || task.status == TaskStatus::Running {
+                        task.update_status(TaskStatus::Completed);
+                    }
+                }
+            }
+        }
+    }
+
+    /// Parse user input and generate task plan (MVP: simple fallback)
+    fn parse_input(&self, user_input: &str) -> Result<Vec<TaskPlan>, PlannerError> {
+        // MVP: Simple single-task fallback for when LLM is unavailable
+        // Real parsing should be done by LLM
+        
+        Ok(vec![TaskPlan {
+            id: self.state.next_id,
+            description: user_input.to_string(),
+            kind: NodeKind::Processing,
+            attachments: Vec::new(),
+        }])
+    }
+
+    /// Generate the next command to dispatch
+    fn generate_next_command(&self) -> Option<PlannerCmd> {
+        // Check if we're waiting for clarification
+        if self.state.waiting_for_clarification {
+            return None;
+        }
+        
+        // Find next undispatched task
+        if let Some(task_id) = self.state.get_next_undispatched_task() {
+            if let Some(task) = self.state.get_task(task_id) {
+                return match task.kind {
+                    NodeKind::Clarification => {
+                        Some(PlannerCmd::RequestClarification {
+                            node_id: task.id,
+                            question: task.description.clone(),
+                        })
+                    }
+                    NodeKind::ToolCall | NodeKind::Processing => {
+                        Some(PlannerCmd::ExecuteTask {
+                            node_id: task.id,
+                            kind: task.kind,
+                            parameters: task.description.clone(),
+                        })
+                    }
+                };
+            }
+        }
+        
+        // Check if all tasks are completed
+        let all_done = self.state.tasks.iter().all(|t| 
+            matches!(t.status, TaskStatus::Completed | TaskStatus::Failed)
+        );
+        
+        if all_done && !self.state.tasks.is_empty() {
+            let summary = self.state.tasks.iter()
+                .filter(|t| t.status == TaskStatus::Completed)
+                .map(|t| &t.description)
+                .cloned()
+                .collect::<Vec<_>>()
+                .join("; ");
+            
+            return Some(PlannerCmd::Complete { summary });
+        }
+        
+        None
+    }
+
+    /// Compact context (MVP: no-op, real implementation uses LLM)
+    fn compact_context(&self, _max_tokens: usize) -> (String, Vec<u64>) {
+        // MVP: Return existing summary without compaction
+        // Real compaction should be done by LLM
+        (self.state.context_summary.clone(), Vec::new())
+    }
+}
+
+impl Handler for Planner {
+    type Command = Command;
+    type Event = Event;
+    type Error = PlannerError;
+
+    fn process(&mut self, command: Self::Command) -> Result<Vec<Self::Event>, Self::Error> {
+        let mut events = Vec::new();
+        
+        match command {
+            Command::Initialize { user_input, attachments } => {
+                // Parse input and plan tasks
+                let tasks = self.parse_input(&user_input)?;
+                
+                // Add attachments to first task if any
+                let mut tasks_with_attachments = tasks;
+                if !attachments.is_empty() && !tasks_with_attachments.is_empty() {
+                    tasks_with_attachments[0].attachments = attachments;
+                }
+                
+                events.push(Event::TasksPlanned {
+                    tasks: tasks_with_attachments,
+                });
+                
+                // Apply the event to update state
+                self.apply_event(&events[0]);
+                
+                // Check if we should dispatch the first task
+                if let Some(cmd) = self.generate_next_command() {
+                    if let Some(task_id) = self.state.get_next_undispatched_task() {
+                        events.push(Event::TaskDispatched {
+                            task_id,
+                            command: cmd,
+                        });
+                        self.apply_event(&events[1]);
+                    }
+                }
+            }
+            
+            Command::HandleExecutorEvent(executor_event) => {
+                match executor_event {
+                    ExecutorEvent::TaskCompleted { node_id, result } => {
+                        events.push(Event::TaskStatusUpdated {
+                            task_id: node_id,
+                            status: TaskStatus::Completed,
+                            result: Some(result),
+                        });
+                        self.apply_event(&events[0]);
+                        
+                        // Try to dispatch next task
+                        if let Some(cmd) = self.generate_next_command() {
+                            if let PlannerCmd::Complete { summary } = cmd {
+                                events.push(Event::PlanningCompleted { summary });
+                            } else if let Some(task_id) = self.state.get_next_undispatched_task() {
+                                events.push(Event::TaskDispatched {
+                                    task_id,
+                                    command: cmd,
+                                });
+                            }
+                            
+                            if events.len() > 1 {
+                                self.apply_event(&events[1]);
+                            }
+                        }
+                    }
+                    
+                    ExecutorEvent::TaskFailed { node_id, error } => {
+                        events.push(Event::TaskStatusUpdated {
+                            task_id: node_id,
+                            status: TaskStatus::Failed,
+                            result: Some(error),
+                        });
+                        self.apply_event(&events[0]);
+                    }
+                    
+                    ExecutorEvent::NeedsClarification { node_id, question } => {
+                        events.push(Event::ClarificationRequested {
+                            task_id: node_id,
+                            question,
+                        });
+                        self.apply_event(&events[0]);
+                    }
+                    
+                    ExecutorEvent::ClarificationProvided { node_id, answer } => {
+                        events.push(Event::ClarificationReceived {
+                            task_id: node_id,
+                            answer,
+                        });
+                        self.apply_event(&events[0]);
+                        
+                        // Resume task execution
+                        if let Some(cmd) = self.generate_next_command() {
+                            events.push(Event::TaskDispatched {
+                                task_id: node_id,
+                                command: cmd,
+                            });
+                            self.apply_event(&events[1]);
+                        }
+                    }
+                }
+            }
+            
+            Command::Continue => {
+                // Continue with next task if any
+                if let Some(cmd) = self.generate_next_command() {
+                    if let PlannerCmd::Complete { summary } = cmd {
+                        events.push(Event::PlanningCompleted { summary });
+                    } else if let Some(task_id) = self.state.get_next_undispatched_task() {
+                        events.push(Event::TaskDispatched {
+                            task_id,
+                            command: cmd,
+                        });
+                    }
+                    
+                    if !events.is_empty() {
+                        self.apply_event(&events[0]);
+                    }
+                }
+            }
+            
+            Command::CompactContext { max_tokens } => {
+                let (summary, removed_ids) = self.compact_context(max_tokens);
+                
+                if !removed_ids.is_empty() {
+                    events.push(Event::ContextCompacted {
+                        summary,
+                        removed_task_ids: removed_ids,
+                    });
+                    self.apply_event(&events[0]);
+                }
+            }
+        }
+        
+        // Store events in log
+        self.event_log.extend(events.clone());
+        
+        Ok(events)
+    }
+
+    fn fold(events: &[Self::Event]) -> Self {
+        let mut planner = Self::new();
+        
+        for event in events {
+            planner.apply_event(event);
+            planner.event_log.push(event.clone());
+        }
+        
+        planner
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_initialize_and_plan() {
+        let mut planner = Planner::new();
+        
+        let events = planner.process(Command::Initialize {
+            user_input: "Analyze the code\nRun tests\nDeploy to production".to_string(),
+            attachments: vec![],
+        }).unwrap();
+        
+        // Should plan tasks and dispatch first one
+        assert!(!events.is_empty());
+        assert!(matches!(&events[0], Event::TasksPlanned { tasks } if tasks.len() == 3));
+        
+        // Should have 3 tasks in state
+        assert_eq!(planner.state().tasks.len(), 3);
+    }
+
+    #[test]
+    fn test_task_execution_flow() {
+        let mut planner = Planner::new();
+        
+        // Initialize with a task
+        planner.process(Command::Initialize {
+            user_input: "Test task".to_string(),
+            attachments: vec![],
+        }).unwrap();
+        
+        // Complete the task
+        let events = planner.process(Command::HandleExecutorEvent(
+            ExecutorEvent::TaskCompleted {
+                node_id: 1,
+                result: "Success".to_string(),
+            }
+        )).unwrap();
+        
+        // Should update status and potentially complete planning
+        assert!(events.iter().any(|e| matches!(e, Event::TaskStatusUpdated { 
+            status: TaskStatus::Completed, .. 
+        })));
+    }
+
+    #[test]
+    fn test_clarification_flow() {
+        let mut planner = Planner::new();
+        
+        // Initialize with a clarification task
+        planner.process(Command::Initialize {
+            user_input: "What is the project name?".to_string(),
+            attachments: vec![],
+        }).unwrap();
+        
+        // Request clarification
+        let events = planner.process(Command::HandleExecutorEvent(
+            ExecutorEvent::NeedsClarification {
+                node_id: 1,
+                question: "Please provide the project name".to_string(),
+            }
+        )).unwrap();
+        
+        assert!(events.iter().any(|e| matches!(e, Event::ClarificationRequested { .. })));
+        assert!(planner.state().waiting_for_clarification);
+        
+        // Provide clarification
+        let events = planner.process(Command::HandleExecutorEvent(
+            ExecutorEvent::ClarificationProvided {
+                node_id: 1,
+                answer: "MyProject".to_string(),
+            }
+        )).unwrap();
+        
+        assert!(events.iter().any(|e| matches!(e, Event::ClarificationReceived { .. })));
+        assert!(!planner.state().waiting_for_clarification);
+    }
+
+    #[test]
+    fn test_fold_reconstructs_state() {
+        let events = vec![
+            Event::TasksPlanned {
+                tasks: vec![
+                    TaskPlan {
+                        id: 1,
+                        description: "Task 1".to_string(),
+                        kind: NodeKind::Processing,
+                        attachments: vec![],
+                    },
+                    TaskPlan {
+                        id: 2,
+                        description: "Task 2".to_string(),
+                        kind: NodeKind::ToolCall,
+                        attachments: vec![],
+                    },
+                ],
+            },
+            Event::TaskDispatched {
+                task_id: 1,
+                command: PlannerCmd::ExecuteTask {
+                    node_id: 1,
+                    kind: NodeKind::Processing,
+                    parameters: "Task 1".to_string(),
+                },
+            },
+            Event::TaskStatusUpdated {
+                task_id: 1,
+                status: TaskStatus::Completed,
+                result: Some("Done".to_string()),
+            },
+        ];
+        
+        let planner = Planner::fold(&events);
+        
+        // State should be reconstructed
+        assert_eq!(planner.state().tasks.len(), 2);
+        assert_eq!(planner.state().tasks[0].status, TaskStatus::Completed);
+        assert!(planner.state().is_dispatched(1));
+        assert_eq!(planner.event_log.len(), 3);
+    }
+
+    #[test]
+    fn test_context_compaction() {
+        let mut planner = Planner::new();
+        
+        // Initialize with multiple tasks
+        planner.process(Command::Initialize {
+            user_input: "Task 1\nTask 2\nTask 3\nTask 4\nTask 5".to_string(),
+            attachments: vec![],
+        }).unwrap();
+        
+        // Complete some tasks
+        for i in 1..=3 {
+            planner.state.get_task_mut(i).unwrap().update_status(TaskStatus::Completed);
+        }
+        
+        // Compact context
+        let events = planner.process(Command::CompactContext {
+            max_tokens: 100, // Small limit to trigger compaction
+        }).unwrap();
+        
+        if !events.is_empty() {
+            assert!(matches!(&events[0], Event::ContextCompacted { .. }));
+        }
+    }
+}
diff --git a/meta_agent/src/planner/llm.rs b/meta_agent/src/planner/llm.rs
new file mode 100644
index 0000000..0ac952a
--- /dev/null
+++ b/meta_agent/src/planner/llm.rs
@@ -0,0 +1,422 @@
+//! LLM integration for intelligent task planning
+//! This module provides LLM-powered capabilities for:
+//! - Parsing natural language into structured tasks
+//! - Identifying task dependencies
+//! - Semantic NodeKind classification
+//! - Context compaction and summarization
+
+use crate::llm::{Completion, LLMClientDyn, CompletionResponse};
+use crate::planner::types::{NodeKind, AttachmentKind, Attachment};
+use crate::planner::handler::{TaskPlan, Event};
+use crate::agent::utils::extract_tag;
+use eyre::Result;
+use rig::message::{Message, AssistantContent};
+use serde::{Deserialize, Serialize};
+use std::collections::HashMap;
+
+/// LLM-powered planner that parses natural language into structured tasks
+pub struct LLMPlanner {
+    llm: Box<dyn LLMClientDyn>,
+    model: String,
+    system_prompt: String,
+}
+
+impl LLMPlanner {
+    pub fn new(llm: Box<dyn LLMClientDyn>, model: String) -> Self {
+        let system_prompt = r#"You are an expert task planner that breaks down complex requests into executable tasks.
+
+Your responsibilities:
+1. Parse natural language into a sequence of clear, actionable tasks
+2. Identify dependencies between tasks
+3. Classify each task type (Processing, ToolCall, or Clarification)
+4. Extract URLs, file references, and other attachments
+5. Preserve the user's intent while making tasks concrete
+
+Task Types:
+- Processing: Analysis, planning, implementation, or general computation tasks
+- ToolCall: Tasks requiring external tools (running commands, tests, API calls)
+- Clarification: Tasks that need user input or have ambiguity
+
+Output Format:
+Provide your response in structured XML format with tasks inside <tasks> tags.
+Each task should have: id, description, kind, dependencies (comma-separated ids), and attachments (if any).
+
+Example:
+<tasks>
+<task>
+  <id>1</id>
+  <description>Analyze the existing codebase structure</description>
+  <kind>Processing</kind>
+  <dependencies></dependencies>
+</task>
+<task>
+  <id>2</id>
+  <description>Run existing unit tests to understand current coverage</description>
+  <kind>ToolCall</kind>
+  <dependencies>1</dependencies>
+</task>
+<task>
+  <id>3</id>
+  <description>What testing framework should we use for new tests?</description>
+  <kind>Clarification</kind>
+  <dependencies>2</dependencies>
+</task>
+</tasks>"#.to_string();
+
+        Self {
+            llm,
+            model,
+            system_prompt,
+        }
+    }
+    
+    /// Extract text content from LLM response
+    fn extract_text_from_response(&self, response: &CompletionResponse) -> Result<String> {
+        for content in response.choice.iter() {
+            if let AssistantContent::Text(text) = content {
+                return Ok(text.text.clone());
+            }
+        }
+        
+        Err(eyre::eyre!("No text content in response"))
+    }
+    
+    /// Parse natural language input into structured tasks using LLM
+    pub async fn parse_tasks(&self, user_input: &str) -> Result<Vec<ParsedTask>> {
+        let prompt = format!(
+            r#"Parse the following user request into a sequence of executable tasks:
+
+<request>
+{}
+</request>
+
+Remember to:
+- Break down complex requests into smaller, manageable tasks
+- Identify any URLs or file references as attachments
+- Mark ambiguous requirements as Clarification tasks
+- Ensure tasks are in logical execution order
+- Set proper dependencies between tasks"#,
+            user_input
+        );
+        
+        let completion = Completion::new(self.model.clone(), Message::user(prompt))
+            .preamble(self.system_prompt.clone())
+            .temperature(0.3) // Lower temperature for more deterministic planning
+            .max_tokens(2000);
+        
+        let response = self.llm.completion(completion).await?;
+        let content = self.extract_text_from_response(&response)?;
+        self.parse_llm_response(&content)
+    }
+    
+    /// Parse LLM response into structured tasks
+    fn parse_llm_response(&self, response: &str) -> Result<Vec<ParsedTask>> {
+        let tasks_xml = extract_tag(response, "tasks")
+            .ok_or_else(|| eyre::eyre!("No tasks found in LLM response"))?;
+        
+        let mut tasks = Vec::new();
+        let mut current_pos = 0;
+        
+        while let Some(task_start) = tasks_xml[current_pos..].find("<task>") {
+            let task_start = current_pos + task_start;
+            if let Some(task_end) = tasks_xml[task_start..].find("</task>") {
+                let task_end = task_start + task_end + "</task>".len();
+                let task_xml = &tasks_xml[task_start..task_end];
+                
+                if let Some(task) = self.parse_single_task(task_xml) {
+                    tasks.push(task);
+                }
+                
+                current_pos = task_end;
+            } else {
+                break;
+            }
+        }
+        
+        Ok(tasks)
+    }
+    
+    /// Parse a single task from XML
+    fn parse_single_task(&self, task_xml: &str) -> Option<ParsedTask> {
+        let id = extract_tag(task_xml, "id")?.parse::<u64>().ok()?;
+        let description = extract_tag(task_xml, "description")?;
+        let kind_str = extract_tag(task_xml, "kind")?;
+        let dependencies_str = extract_tag(task_xml, "dependencies").unwrap_or_default();
+        
+        let kind = match kind_str.to_lowercase().as_str() {
+            "processing" => NodeKind::Processing,
+            "toolcall" | "tool" => NodeKind::ToolCall,
+            "clarification" | "clarify" => NodeKind::Clarification,
+            _ => NodeKind::Processing,
+        };
+        
+        let dependencies = if dependencies_str.is_empty() {
+            Vec::new()
+        } else {
+            dependencies_str
+                .split(',')
+                .filter_map(|s| s.trim().parse::<u64>().ok())
+                .collect()
+        };
+        
+        // Extract attachments (URLs, files) from description
+        let attachments = self.extract_attachments(&description);
+        
+        Some(ParsedTask {
+            id,
+            description,
+            kind,
+            dependencies,
+            attachments,
+        })
+    }
+    
+    /// Extract attachments from task description
+    fn extract_attachments(&self, description: &str) -> Vec<Attachment> {
+        let mut attachments = Vec::new();
+        
+        // Extract URLs
+        let url_regex = regex::Regex::new(r"https?://[^\s]+").unwrap();
+        for url_match in url_regex.find_iter(description) {
+            let url = url_match.as_str().to_string();
+            attachments.push(Attachment {
+                kind: AttachmentKind::Link(url.clone()),
+                label: Some(format!("URL: {}", url)),
+            });
+        }
+        
+        // Extract file paths (more precise pattern - must have path separators or start with src/etc)
+        let file_regex = regex::Regex::new(r"\b(?:src/|tests/|\./)[\w/]+\.\w+\b").unwrap();
+        for file_match in file_regex.find_iter(description) {
+            let file = file_match.as_str().to_string();
+            if !file.starts_with("http") { // Avoid URLs
+                attachments.push(Attachment {
+                    kind: AttachmentKind::FileRef(file.clone()),
+                    label: Some(format!("File: {}", file)),
+                });
+            }
+        }
+        
+        attachments
+    }
+    
+    /// Classify NodeKind using semantic understanding
+    pub async fn classify_node_kind(&self, task_description: &str) -> Result<NodeKind> {
+        let prompt = format!(
+            r#"Classify the following task into one of these categories:
+            
+1. Processing - Analysis, planning, implementation, or general computation tasks
+2. ToolCall - Tasks requiring external tools (running commands, tests, API calls)
+3. Clarification - Tasks that need user input or have ambiguity
+
+Task: "{}"
+
+Respond with just the category name: Processing, ToolCall, or Clarification"#,
+            task_description
+        );
+        
+        let completion = Completion::new(self.model.clone(), Message::user(prompt))
+            .temperature(0.1)
+            .max_tokens(10);
+        
+        let response = self.llm.completion(completion).await?;
+        let content = self.extract_text_from_response(&response)?;
+        let kind_str = content.trim().to_lowercase();
+        
+        Ok(match kind_str.as_str() {
+            "toolcall" | "tool" => NodeKind::ToolCall,
+            "clarification" | "clarify" => NodeKind::Clarification,
+            _ => NodeKind::Processing,
+        })
+    }
+    
+    /// Compact context using LLM to manage token budget
+    pub async fn compact_context(
+        &self,
+        events: &[Event],
+        token_budget: usize,
+    ) -> Result<String> {
+        // Build context from events
+        let mut context_parts = Vec::new();
+        for event in events {
+            match event {
+                Event::TaskStatusUpdated { task_id, status, result } => {
+                    if let Some(result) = result {
+                        context_parts.push(format!("Task {}: {} (Status: {:?})", task_id, result, status));
+                    }
+                }
+                Event::ClarificationReceived { task_id, answer } => {
+                    context_parts.push(format!("Clarification for task {}: {}", task_id, answer));
+                }
+                _ => {}
+            }
+        }
+        
+        let full_context = context_parts.join("\n");
+        
+        // Estimate tokens (rough approximation: 1 token â‰ˆ 4 chars)
+        let estimated_tokens = full_context.len() / 4;
+        if estimated_tokens <= token_budget {
+            return Ok(full_context);
+        }
+        
+        // Use LLM to summarize
+        let prompt = format!(
+            r#"Summarize the following task execution context to fit within {} tokens (approximately {} characters).
+Keep the most important information about completed tasks, decisions made, and key results.
+
+Context:
+{}
+
+Provide a concise summary that preserves essential information for continuing the task sequence."#,
+            token_budget,
+            token_budget * 4,
+            full_context
+        );
+        
+        let completion = Completion::new(self.model.clone(), Message::user(prompt))
+            .temperature(0.3)
+            .max_tokens(token_budget as u64);
+        
+        let response = self.llm.completion(completion).await?;
+        let content = self.extract_text_from_response(&response)?;
+        Ok(content)
+    }
+    
+    /// Analyze task dependencies and suggest optimal ordering
+    pub async fn analyze_dependencies(&self, tasks: &[ParsedTask]) -> Result<DependencyAnalysis> {
+        let task_descriptions: Vec<String> = tasks
+            .iter()
+            .map(|t| format!("{}: {}", t.id, t.description))
+            .collect();
+        
+        let prompt = format!(
+            r#"Analyze the dependencies between these tasks and suggest the optimal execution order.
+
+Tasks:
+{}
+
+For each task, identify:
+1. Which tasks it depends on (must complete before)
+2. Which tasks can run in parallel with it
+3. Any potential bottlenecks or critical path issues
+
+Respond in JSON format:
+{{
+  "dependencies": {{"task_id": [dependency_ids], ...}},
+  "parallel_groups": [[task_ids_that_can_run_together], ...],
+  "critical_path": [task_ids_in_order],
+  "bottlenecks": ["description of bottleneck", ...]
+}}"#,
+            task_descriptions.join("\n")
+        );
+        
+        let completion = Completion::new(self.model.clone(), Message::user(prompt))
+            .temperature(0.2)
+            .max_tokens(1000);
+        
+        let response = self.llm.completion(completion).await?;
+        let content = self.extract_text_from_response(&response)?;
+        
+        // Parse JSON response
+        let analysis: DependencyAnalysis = serde_json::from_str(&content)
+            .unwrap_or_else(|_| DependencyAnalysis::default());
+        
+        Ok(analysis)
+    }
+}
+
+/// Parsed task from LLM
+#[derive(Debug, Clone)]
+pub struct ParsedTask {
+    pub id: u64,
+    pub description: String,
+    pub kind: NodeKind,
+    pub dependencies: Vec<u64>,
+    pub attachments: Vec<Attachment>,
+}
+
+impl From<ParsedTask> for TaskPlan {
+    fn from(parsed: ParsedTask) -> Self {
+        TaskPlan {
+            id: parsed.id,
+            description: parsed.description,
+            kind: parsed.kind,
+            attachments: parsed.attachments,
+        }
+    }
+}
+
+/// Dependency analysis result
+#[derive(Debug, Clone, Default, Serialize, Deserialize)]
+pub struct DependencyAnalysis {
+    /// Map of task ID to its dependencies
+    pub dependencies: HashMap<u64, Vec<u64>>,
+    /// Groups of tasks that can run in parallel
+    pub parallel_groups: Vec<Vec<u64>>,
+    /// Critical path through the task graph
+    pub critical_path: Vec<u64>,
+    /// Identified bottlenecks
+    pub bottlenecks: Vec<String>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    // Simple mock LLM client for testing
+    struct TestLLMClient;
+    
+    impl LLMClientDyn for TestLLMClient {
+        fn completion(&self, _completion: Completion) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<CompletionResponse>> + Send + '_>> {
+            Box::pin(async move {
+                Ok(CompletionResponse {
+                    choice: rig::OneOrMany::one(AssistantContent::Text(rig::message::Text {
+                        text: "test response".to_string(),
+                    })),
+                    finish_reason: crate::llm::FinishReason::Stop,
+                    output_tokens: 0,
+                    input_tokens: 0,
+                    cache_read_input_tokens: None,
+                    cache_creation_input_tokens: None,
+                })
+            })
+        }
+    }
+    
+    #[test]
+    fn test_extract_attachments() {
+        let planner = LLMPlanner::new(
+            Box::new(TestLLMClient),
+            "test".to_string(),
+        );
+        
+        let description = "Read the API spec at https://example.com/api.pdf and analyze src/main.rs";
+        let attachments = planner.extract_attachments(description);
+        
+        assert_eq!(attachments.len(), 2);
+        assert!(matches!(&attachments[0].kind, AttachmentKind::Link(url) if url == "https://example.com/api.pdf"));
+        assert!(matches!(&attachments[1].kind, AttachmentKind::FileRef(file) if file == "src/main.rs"));
+    }
+    
+    #[test]
+    fn test_parse_single_task() {
+        let planner = LLMPlanner::new(
+            Box::new(TestLLMClient),
+            "test".to_string(),
+        );
+        
+        let task_xml = r#"<task>
+            <id>1</id>
+            <description>Analyze the codebase</description>
+            <kind>Processing</kind>
+            <dependencies></dependencies>
+        </task>"#;
+        
+        let task = planner.parse_single_task(task_xml).unwrap();
+        assert_eq!(task.id, 1);
+        assert_eq!(task.description, "Analyze the codebase");
+        assert!(matches!(task.kind, NodeKind::Processing));
+        assert!(task.dependencies.is_empty());
+    }
+}
diff --git a/meta_agent/src/planner/mod.rs b/meta_agent/src/planner/mod.rs
new file mode 100644
index 0000000..6bdfb83
--- /dev/null
+++ b/meta_agent/src/planner/mod.rs
@@ -0,0 +1,30 @@
+/// Event-sourced planner module for meta_agent
+/// 
+/// This module implements a task planner that:
+/// - Parses user input into executable tasks
+/// - Manages task execution via event sourcing
+/// - Handles clarification requests
+/// - Compacts context to manage token limits
+
+pub mod handler;
+pub mod types;
+pub mod llm;
+pub mod cli;
+
+#[cfg(feature = "mq")]
+pub mod mq;
+
+// Re-export core handler trait and implementation
+pub use handler::{Command, Event, Handler, Planner, PlannerError, TaskPlan};
+
+// Re-export types
+pub use types::{
+    NodeKind, TaskStatus, PlannerCmd, ExecutorEvent,
+    AttachmentKind, Attachment, Task, PlannerState, PlannerConfig
+};
+
+// Re-export for convenience
+pub use types::{
+    NodeKind::{Clarification, ToolCall, Processing},
+    TaskStatus::{Planned, Running, Completed, NeedsClarification, Failed},
+};
diff --git a/meta_agent/src/planner/mq.rs b/meta_agent/src/planner/mq.rs
new file mode 100644
index 0000000..60ed589
--- /dev/null
+++ b/meta_agent/src/planner/mq.rs
@@ -0,0 +1,29 @@
+use crate::planner::handler::Event;
+use dabgent_mq::models::Event as MqEvent;
+
+impl MqEvent for Event {
+    const EVENT_VERSION: &'static str = "1.0";
+
+    fn event_type(&self) -> &'static str {
+        // Return variant-specific event types for better routing
+        // This enables specialized executors to subscribe to specific events
+        "PlannerEvent"  // Base type - variants can be filtered via Query
+    }
+}
+
+// Helper for getting variant-specific event type (for future routing)
+impl Event {
+    pub fn variant_type(&self) -> &'static str {
+        match self {
+            Event::TasksPlanned { .. } => "TasksPlanned",
+            Event::TaskDispatched { .. } => "TaskDispatched",
+            Event::TaskStatusUpdated { .. } => "TaskStatusUpdated",
+            Event::ClarificationRequested { .. } => "ClarificationRequested",
+            Event::ClarificationReceived { .. } => "ClarificationReceived",
+            Event::ContextCompacted { .. } => "ContextCompacted",
+            Event::PlanningCompleted { .. } => "PlanningCompleted",
+        }
+    }
+}
+
+
diff --git a/meta_agent/src/planner/types.rs b/meta_agent/src/planner/types.rs
new file mode 100644
index 0000000..3bea9e9
--- /dev/null
+++ b/meta_agent/src/planner/types.rs
@@ -0,0 +1,342 @@
+use serde::{Deserialize, Serialize};
+use std::collections::HashMap;
+
+/// Classification for routing & tooling (v1 minimal set)
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+pub enum NodeKind {
+    /// Explicit user Q/A
+    Clarification,
+    /// External tool execution
+    ToolCall,
+    /// Generic planning/analysis/implementation
+    Processing,
+}
+
+/// Task execution status
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+pub enum TaskStatus {
+    /// Task is planned but not yet started
+    Planned,
+    /// Task is currently being executed
+    Running,
+    /// Task has completed successfully
+    Completed,
+    /// Task needs user clarification
+    NeedsClarification,
+    /// Task has failed
+    Failed,
+}
+
+/// Commands emitted by the planner to the executor (published to bus)
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum PlannerCmd {
+    /// Execute a specific task
+    ExecuteTask {
+        node_id: u64,
+        kind: NodeKind,
+        parameters: String,
+    },
+    /// Request clarification from user
+    RequestClarification {
+        node_id: u64,
+        question: String,
+    },
+    /// Signal completion of all tasks
+    Complete {
+        summary: String,
+    },
+}
+
+/// Events received by the planner from the executor/UI (consumed from bus)
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum ExecutorEvent {
+    /// Task completed successfully
+    TaskCompleted {
+        node_id: u64,
+        result: String,
+    },
+    /// Task failed with error
+    TaskFailed {
+        node_id: u64,
+        error: String,
+    },
+    /// Task needs clarification
+    NeedsClarification {
+        node_id: u64,
+        question: String,
+    },
+    /// User provided clarification
+    ClarificationProvided {
+        node_id: u64,
+        answer: String,
+    },
+}
+
+/// Attachment types (MVP: just URLs and files)
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum AttachmentKind {
+    /// URL reference
+    Link(String),
+    /// File reference (path)
+    FileRef(String),
+}
+
+/// Attachment with metadata
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct Attachment {
+    pub kind: AttachmentKind,
+    pub label: Option<String>,
+}
+
+/// Individual task in the execution plan
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct Task {
+    /// Unique task identifier
+    pub id: u64,
+    /// Human-readable task description
+    pub description: String,
+    /// Task classification for routing
+    pub kind: NodeKind,
+    /// Current execution status
+    pub status: TaskStatus,
+    /// Associated attachments (URLs, files, etc.)
+    pub attachments: Vec<Attachment>,
+    /// Timestamp when task was created
+    pub created_at: u64,
+    /// Timestamp when task was last updated
+    pub updated_at: u64,
+}
+
+impl Task {
+    /// Create a new task with the given parameters
+    pub fn new(id: u64, description: String, kind: NodeKind) -> Self {
+        let now = std::time::SystemTime::now()
+            .duration_since(std::time::UNIX_EPOCH)
+            .unwrap()
+            .as_secs();
+
+        Self {
+            id,
+            description,
+            kind,
+            status: TaskStatus::Planned,
+            attachments: Vec::new(),
+            created_at: now,
+            updated_at: now,
+        }
+    }
+
+    /// Update task status and timestamp
+    pub fn update_status(&mut self, status: TaskStatus) {
+        self.status = status;
+        self.updated_at = std::time::SystemTime::now()
+            .duration_since(std::time::UNIX_EPOCH)
+            .unwrap()
+            .as_secs();
+    }
+
+    /// Add an attachment to the task
+    pub fn add_attachment(&mut self, attachment: Attachment) {
+        self.attachments.push(attachment);
+    }
+}
+
+/// Planner state that can be rebuilt from events
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct PlannerState {
+    /// All tasks in the execution plan
+    pub tasks: Vec<Task>,
+    /// Current position in task sequence
+    pub cursor: usize,
+    /// Whether planner is waiting for clarification
+    pub waiting_for_clarification: bool,
+    /// Task ID waiting for clarification
+    pub pending_clarification_for: Option<u64>,
+    /// Next available task ID
+    pub next_id: u64,
+    /// Compacted context summary
+    pub context_summary: String,
+    /// Track which tasks have been dispatched (for idempotency)
+    pub dispatched_tasks: HashMap<u64, u64>, // task_id -> timestamp
+}
+
+impl Default for PlannerState {
+    fn default() -> Self {
+        Self {
+            tasks: Vec::new(),
+            cursor: 0,
+            waiting_for_clarification: false,
+            pending_clarification_for: None,
+            next_id: 1,
+            context_summary: String::new(),
+            dispatched_tasks: HashMap::new(),
+        }
+    }
+}
+
+impl PlannerState {
+    /// Get a task by ID
+    pub fn get_task(&self, id: u64) -> Option<&Task> {
+        self.tasks.iter().find(|t| t.id == id)
+    }
+
+    /// Get a mutable task by ID
+    pub fn get_task_mut(&mut self, id: u64) -> Option<&mut Task> {
+        self.tasks.iter_mut().find(|t| t.id == id)
+    }
+
+    /// Get the next undispatched task
+    pub fn get_next_undispatched_task(&self) -> Option<u64> {
+        if self.cursor >= self.tasks.len() {
+            return None;
+        }
+
+        let task = &self.tasks[self.cursor];
+        if task.status == TaskStatus::Planned && !self.dispatched_tasks.contains_key(&task.id) {
+            Some(task.id)
+        } else {
+            None
+        }
+    }
+
+    /// Check if a task has been dispatched
+    pub fn is_dispatched(&self, task_id: u64) -> bool {
+        self.dispatched_tasks.contains_key(&task_id)
+    }
+
+    /// Mark a task as dispatched
+    pub fn mark_dispatched(&mut self, task_id: u64) {
+        let timestamp = std::time::SystemTime::now()
+            .duration_since(std::time::UNIX_EPOCH)
+            .unwrap()
+            .as_secs();
+        self.dispatched_tasks.insert(task_id, timestamp);
+    }
+
+    /// Advance to the next task
+    pub fn advance_cursor(&mut self) {
+        if self.cursor < self.tasks.len() {
+            self.cursor += 1;
+        }
+    }
+
+    /// Reset clarification state
+    pub fn clear_clarification(&mut self) {
+        self.waiting_for_clarification = false;
+        self.pending_clarification_for = None;
+    }
+
+    /// Set clarification state
+    pub fn set_clarification(&mut self, task_id: u64) {
+        self.waiting_for_clarification = true;
+        self.pending_clarification_for = Some(task_id);
+    }
+
+    /// Allocate a new task ID
+    pub fn alloc_id(&mut self) -> u64 {
+        let id = self.next_id;
+        self.next_id += 1;
+        id
+    }
+
+    /// Add a new task to the plan
+    pub fn add_task(&mut self, description: String, kind: NodeKind) -> u64 {
+        let id = self.alloc_id();
+        let task = Task::new(id, description, kind);
+        self.tasks.push(task);
+        id
+    }
+
+    /// Get conversation thread for compaction
+    pub fn get_thread(&self) -> Vec<String> {
+        let mut thread = Vec::new();
+
+        if !self.context_summary.is_empty() {
+            thread.push(format!("Context: {}", self.context_summary));
+        }
+
+        for task in &self.tasks {
+            if task.status == TaskStatus::Completed {
+                thread.push(format!("Task {}: {}", task.id, task.description));
+            }
+        }
+
+        thread
+    }
+}
+
+/// Planner configuration (MVP: minimal config)
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct PlannerConfig {
+    /// Maximum tokens for context
+    pub token_budget: usize,
+}
+
+impl Default for PlannerConfig {
+    fn default() -> Self {
+        Self {
+            token_budget: 4000,
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_task_creation() {
+        let task = Task::new(1, "Test task".to_string(), NodeKind::Processing);
+        assert_eq!(task.id, 1);
+        assert_eq!(task.status, TaskStatus::Planned);
+        assert_eq!(task.kind, NodeKind::Processing);
+    }
+
+    #[test]
+    fn test_task_status_update() {
+        let mut task = Task::new(1, "Test task".to_string(), NodeKind::Processing);
+        task.update_status(TaskStatus::Running);
+        assert_eq!(task.status, TaskStatus::Running);
+        assert!(task.updated_at >= task.created_at);
+    }
+
+    #[test]
+    fn test_planner_state_task_management() {
+        let mut state = PlannerState::default();
+        let id1 = state.add_task("First task".to_string(), NodeKind::Processing);
+        let id2 = state.add_task("Second task".to_string(), NodeKind::ToolCall);
+
+        assert_eq!(state.tasks.len(), 2);
+        assert_eq!(id1, 1);
+        assert_eq!(id2, 2);
+
+        let task = state.get_task(id1).unwrap();
+        assert_eq!(task.description, "First task");
+    }
+
+    #[test]
+    fn test_planner_state_dispatch_tracking() {
+        let mut state = PlannerState::default();
+        let id = state.add_task("Test task".to_string(), NodeKind::Processing);
+        assert!(!state.is_dispatched(id));
+        state.mark_dispatched(id);
+        assert!(state.is_dispatched(id));
+        assert_eq!(state.get_next_undispatched_task(), None);
+    }
+
+    #[test]
+    fn test_planner_state_clarification() {
+        let mut state = PlannerState::default();
+        let id = state.add_task("Test task".to_string(), NodeKind::Clarification);
+        assert!(!state.waiting_for_clarification);
+        assert_eq!(state.pending_clarification_for, None);
+        state.set_clarification(id);
+        assert!(state.waiting_for_clarification);
+        assert_eq!(state.pending_clarification_for, Some(id));
+        state.clear_clarification();
+        assert!(!state.waiting_for_clarification);
+        assert_eq!(state.pending_clarification_for, None);
+    }
+}
+
+
diff --git a/meta_agent/tests/event_store_test.rs b/meta_agent/tests/event_store_test.rs
new file mode 100644
index 0000000..32be35e
--- /dev/null
+++ b/meta_agent/tests/event_store_test.rs
@@ -0,0 +1,28 @@
+use meta_agent::events::{EventMetadata, InMemoryEventStore, PersistedEvent, EventStore};
+
+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
+enum Evt { X(u32), Y(&'static str) }
+
+#[test]
+fn event_store_roundtrip() {
+    let mut store: InMemoryEventStore<Evt> = InMemoryEventStore::new();
+
+    let e = PersistedEvent {
+        meta: EventMetadata {
+            id: "e1".into(),
+            aggregate_id: "p1".into(),
+            timestamp: 123,
+            causation_id: None,
+            correlation_id: None,
+            version: 1,
+        },
+        payload: Evt::X(7),
+    };
+
+    store.append(e.clone());
+    let all = store.load_all();
+    assert_eq!(all.len(), 1);
+    assert_eq!(all[0].payload, e.payload);
+}
+
+
diff --git a/meta_agent/tests/mq_integration_test.rs b/meta_agent/tests/mq_integration_test.rs
new file mode 100644
index 0000000..7d61525
--- /dev/null
+++ b/meta_agent/tests/mq_integration_test.rs
@@ -0,0 +1,41 @@
+#![cfg(feature = "mq")]
+
+use meta_agent::planner::{handler::{Handler, Command, Event}, Planner};
+use dabgent_mq::db::{sqlite::SqliteStore, EventStore, Query, Metadata};
+
+#[tokio::test]
+async fn test_planner_events_persist_and_replay() {
+    // in-memory sqlite pool
+    let pool = sqlx::sqlite::SqlitePoolOptions::new()
+        .max_connections(5)
+        .connect("sqlite::memory:")
+        .await
+        .expect("pool");
+
+    let store = SqliteStore::new(pool);
+    store.migrate().await;
+
+    // run planner
+    let mut planner = Planner::new();
+    let events = planner.process(Command::Initialize {
+        user_input: "Task A\nTask B".to_string(),
+        attachments: vec![],
+    }).expect("planner init");
+
+    // persist emitted events
+    let aggregate_id = "session-1";
+    for ev in &events {
+        store.push_event("planner", aggregate_id, ev, &Metadata::default()).await.expect("push");
+    }
+
+    // load and fold to reconstruct state
+    let query = Query { stream_id: "planner".into(), event_type: None, aggregate_id: Some(aggregate_id.into()) };
+    let loaded: Vec<Event> = store.load_events(&query, None).await.expect("load");
+    let restored = Planner::fold(&loaded);
+
+    // basic assertions
+    assert_eq!(restored.state().tasks.len(), planner.state().tasks.len());
+    assert_eq!(restored.events().len(), planner.events().len());
+}
+
+
diff --git a/meta_agent/tests/planner_handler_test.rs b/meta_agent/tests/planner_handler_test.rs
new file mode 100644
index 0000000..ee947c0
--- /dev/null
+++ b/meta_agent/tests/planner_handler_test.rs
@@ -0,0 +1,154 @@
+use meta_agent::planner::{
+    Command, Event, Handler, NodeKind, Planner, PlannerCmd, TaskStatus,
+};
+
+#[test]
+fn planner_initialize_and_plan() {
+    let mut planner = Planner::new();
+
+    let events = planner
+        .process(Command::Initialize {
+            user_input: "Analyze the code\nRun tests\nDeploy".to_string(),
+            attachments: vec![],
+        })
+        .expect("initialize should succeed");
+
+    assert!(!events.is_empty());
+    // MVP: Basic planner creates single task
+    assert!(matches!(&events[0], Event::TasksPlanned { tasks } if tasks.len() == 1));
+    assert_eq!(planner.state().tasks.len(), 1);
+}
+
+#[test]
+fn planner_task_execution_flow() {
+    let mut planner = Planner::new();
+
+    planner
+        .process(Command::Initialize {
+            user_input: "Test task".to_string(),
+            attachments: vec![],
+        })
+        .unwrap();
+
+    let events = planner
+        .process(Command::HandleExecutorEvent(
+            meta_agent::planner::ExecutorEvent::TaskCompleted {
+                node_id: 1,
+                result: "ok".to_string(),
+            },
+        ))
+        .unwrap();
+
+    assert!(events.iter().any(|e| matches!(
+        e,
+        Event::TaskStatusUpdated { status: TaskStatus::Completed, .. }
+    )));
+}
+
+#[test]
+fn planner_clarification_flow() {
+    let mut planner = Planner::new();
+
+    planner
+        .process(Command::Initialize {
+            user_input: "What is the project name?".to_string(),
+            attachments: vec![],
+        })
+        .unwrap();
+
+    let events = planner
+        .process(Command::HandleExecutorEvent(
+            meta_agent::planner::ExecutorEvent::NeedsClarification {
+                node_id: 1,
+                question: "Provide project name".to_string(),
+            },
+        ))
+        .unwrap();
+
+    assert!(events.iter().any(|e| matches!(e, Event::ClarificationRequested { .. })));
+    assert!(planner.state().waiting_for_clarification);
+
+    let events = planner
+        .process(Command::HandleExecutorEvent(
+            meta_agent::planner::ExecutorEvent::ClarificationProvided {
+                node_id: 1,
+                answer: "MyProject".to_string(),
+            },
+        ))
+        .unwrap();
+
+    assert!(events.iter().any(|e| matches!(e, Event::ClarificationReceived { .. })));
+    assert!(!planner.state().waiting_for_clarification);
+}
+
+#[test]
+fn planner_fold_reconstructs_state() {
+    let events = vec![
+        Event::TasksPlanned {
+            tasks: vec![
+                meta_agent::planner::TaskPlan {
+                    id: 1,
+                    description: "Task 1".to_string(),
+                    kind: NodeKind::Processing,
+                    attachments: vec![],
+                },
+                meta_agent::planner::TaskPlan {
+                    id: 2,
+                    description: "Task 2".to_string(),
+                    kind: NodeKind::ToolCall,
+                    attachments: vec![],
+                },
+            ],
+        },
+        Event::TaskDispatched {
+            task_id: 1,
+            command: PlannerCmd::ExecuteTask {
+                node_id: 1,
+                kind: NodeKind::Processing,
+                parameters: "Task 1".to_string(),
+            },
+        },
+        Event::TaskStatusUpdated {
+            task_id: 1,
+            status: TaskStatus::Completed,
+            result: Some("Done".to_string()),
+        },
+    ];
+
+    let planner = Planner::fold(&events);
+
+    assert_eq!(planner.state().tasks.len(), 2);
+    assert_eq!(planner.state().tasks[0].status, TaskStatus::Completed);
+    assert!(planner.state().is_dispatched(1));
+}
+
+#[test]
+fn planner_context_compaction() {
+    let mut planner = Planner::new();
+
+    planner
+        .process(Command::Initialize {
+            user_input: "Task 1\nTask 2\nTask 3\nTask 4\nTask 5".to_string(),
+            attachments: vec![],
+        })
+        .unwrap();
+
+    for i in 1..=3u64 {
+        let _ = planner.process(Command::HandleExecutorEvent(
+            meta_agent::planner::ExecutorEvent::TaskCompleted {
+                node_id: i,
+                result: "done".to_string(),
+            },
+        ));
+    }
+
+    let events = planner
+        .process(Command::CompactContext { max_tokens: 100 })
+        .unwrap();
+
+    if !events.is_empty() {
+        assert!(matches!(&events[0], Event::ContextCompacted { .. }));
+    }
+}
+
+
