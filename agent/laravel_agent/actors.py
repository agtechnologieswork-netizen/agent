import jinja2
import logging
import anyio
from typing import Callable, Awaitable
from core.base_node import Node
from core.workspace import Workspace
from core.actors import BaseData, FileOperationsActor
from llm.common import AsyncLLM, Message, TextRaw, ToolUse, ToolUseResult
from laravel_agent import playbooks
from laravel_agent.utils import run_migrations, run_tests
from laravel_agent.playbooks import validate_migration_syntax, MIGRATION_SYNTAX_EXAMPLE
from core.notification_utils import notify_if_callback, notify_stage

logger = logging.getLogger(__name__)


class LaravelActor(FileOperationsActor):
    root: Node[BaseData] | None = None

    def __init__(
        self,
        llm: AsyncLLM,
        workspace: Workspace,
        beam_width: int = 3,
        max_depth: int = 30,
        system_prompt: str = playbooks.APPLICATION_SYSTEM_PROMPT,
        files_protected: list[str] = None,
        files_allowed: list[str] = None,
        event_callback: Callable[[str], Awaitable[None]] | None = None,
    ):
        super().__init__(llm, workspace, beam_width, max_depth)
        self.system_prompt = system_prompt
        self.event_callback = event_callback
        
        # Protected paths are files/directories that should NOT be modified
        # Note: allowed paths take precedence over protected paths
        self.files_protected = files_protected or [
            # Core Laravel framework files
            "vendor/",
            "bootstrap/cache/",
            "bootstrap/app.php",
            "artisan",
            "composer.json",
            "composer.lock",
            "package.json",
            "package-lock.json",
            ".env",
            ".env.example",
            
            # Configuration files that shouldn't be modified
            "config/app.php",
            "config/database.php",
            "config/auth.php",
            "config/session.php",
            "config/cache.php",
            "config/queue.php",
            
            # Core application files
            "app/Providers/",
            "app/Http/Kernel.php",
            "app/Console/Kernel.php",
            "app/Exceptions/Handler.php",
            
            # Public assets that shouldn't be modified
            "public/index.php",
            "public/.htaccess",
            "public/robots.txt",
            
            # Storage (except app folder)
            "storage/framework/",
            "storage/logs/",
            
            # Build and config files
            "webpack.mix.js",
            "vite.config.js",
            "vite.config.ts",
            "resources/js/app.tsx",  # Contains import.meta.glob pattern
            "tailwind.config.js",
            "postcss.config.js",
            ".gitignore",
            ".gitattributes",
            
            # Docker and deployment
            "docker/",
            "Dockerfile",
            "docker-compose.yml",
            ".dockerignore",
            
            # Testing infrastructure
            "phpunit.xml",
            "tests/TestCase.php",
            "tests/CreatesApplication.php"
        ]
        self.files_allowed = files_allowed  or [
            # Core application directories
            "resources/js/pages/", 
            "resources/js/Pages/",  # Inertia.js convention
            "app/Http/Controllers/Auth/",
            "app/Http/Controllers/",
            "app/Models/",
            "app/Services/",
            "app/Repositories/",
            "app/Http/Requests/",
            "app/Http/Resources/",
            "app/Http/Middleware/",
            
            # Routes - but note that some routes files might be protected
            "routes/",
            
            # Database directories
            "database/migrations/",
            "database/seeders/",
            "database/factories/",
            
            # Frontend resources
            "resources/views/",
            "resources/js/components/",
            "resources/js/hooks/",
            "resources/js/lib/",
            "resources/js/types/",
            "resources/css/",
            
            # Localization
            "lang/",
            
            # Testing
            "tests/Feature/",
            "tests/Unit/",
            
            # Public directories - these might have issues:
            # "storage/app/public/",  # Storage might have permission issues in Docker
            # "public/css/",          # Usually generated by build process
            # "public/js/",           # Usually generated by build process
            
            "public/images/",
            
            # Configuration files that CAN be modified
            "vite.config.ts",  # Agent needs to modify this to add new pages
        ]

    async def execute(
        self,
        files: dict[str, str],
        user_prompt: str,
    ) -> Node[BaseData]:
        await notify_stage(self.event_callback, "🚀 Starting Laravel application generation", "in_progress")

        workspace = self.workspace.clone()
        logger.info(
            f"Start {self.__class__.__name__} execution with files: {files.keys()}"
        )
        for file_path, content in files.items():
            workspace.write_file(file_path, content)
        workspace.permissions(
            protected=self.files_protected, allowed=self.files_allowed
        )

        jinja_env = jinja2.Environment()
        user_prompt_template = jinja_env.from_string(playbooks.USER_PROMPT)
        repo_files = await self.get_repo_files(workspace, files)
        project_context = "\n".join(
            [
                "Project files:",
                *repo_files,
                "Writeable files and directories:",
                *[f"- {path}" for path in self.files_allowed],
            ]
        )
        user_prompt_rendered = user_prompt_template.render(
            project_context=project_context,
            user_prompt=user_prompt,
        )
        message = Message(role="user", content=[TextRaw(user_prompt_rendered)])
        self.root = Node(BaseData(workspace, [message], {}))

        solution: Node[BaseData] | None = None
        iteration = 0
        while solution is None:
            iteration += 1
            candidates = self.select(self.root)
            if not candidates:
                logger.info("No candidates to evaluate, search terminated")
                break

            await notify_if_callback(self.event_callback, f"🔄 Working on implementation (iteration {iteration})...", "iteration progress")

            logger.info(
                f"Iteration {iteration}: Running LLM on {len(candidates)} candidates"
            )
            nodes = await self.run_llm(
                candidates,
                system_prompt=self.system_prompt,
                tools=self.tools,
                max_tokens=8192,
            )
            logger.info(f"Received {len(nodes)} nodes from LLM")

            for i, new_node in enumerate(nodes):
                logger.info(f"Evaluating node {i + 1}/{len(nodes)}")
                if await self.eval_node(new_node, user_prompt):
                    logger.info(f"Found solution at depth {new_node.depth}")
                    await notify_stage(self.event_callback, "✅ Laravel application generated successfully", "completed")
                    solution = new_node
                    break
        if solution is None:
            logger.error(f"{self.__class__.__name__} failed to find a solution")
            await notify_stage(self.event_callback, "❌ Laravel application generation failed", "failed")
            raise ValueError("No solutions found")
        return solution

    def select(self, node: Node[BaseData]) -> list[Node[BaseData]]:
        candidates = []
        all_children = node.get_all_children()
        for n in all_children:
            if n.is_leaf and n.depth <= self.max_depth:
                if n.data.should_branch:
                    effective_beam_width = (
                        1 if len(all_children) > (n.depth + 1) else self.beam_width
                    )  # meaning we already branched once
                    logger.info(
                        f"Selecting candidates with effective beam width: {effective_beam_width}, current depth: {n.depth}/{self.max_depth}"
                    )
                    candidates.extend([n] * effective_beam_width)
                else:
                    candidates.append(n)
        logger.info(f"Selected {len(candidates)} leaf nodes for evaluation")
        return candidates

    async def run_ts_type_checks(self, node: Node[BaseData]) -> str | None:
        # CRITICAL: Ziggy-js causes typecheck to fail, agent fixes this but template has to be updated
        type_check_result = await node.data.workspace.exec(
            ["npm", "run", "types"]
        )
        if type_check_result.exit_code != 0:
            return f"{type_check_result.stdout}\n{type_check_result.stderr}"
        return None

    async def run_ts_lint_checks(self, node: Node[BaseData]) -> str | None:
        ts_lint_result = await node.data.workspace.exec(
            ["npm", "run", "lint"]
        )
        if ts_lint_result.exit_code != 0:
            return f"{ts_lint_result.stdout}\n{ts_lint_result.stderr}"
        return None

    async def run_php_lint_checks(self, node: Node[BaseData]) -> str | None:
        # First run Pint to format the code
        pint_result = await node.data.workspace.exec(
            ["vendor/bin/pint", "--preset", "laravel"]
        )
        # Pint returns 1 if it made changes, which is OK
        if pint_result.exit_code not in [0, 1]:
            logger.warning(f"Pint formatting failed: {pint_result.stderr}")
        
        # Then run PHPStan for actual lint checks
        php_lint_result = await node.data.workspace.exec(
            ["composer", "lint"]
        )
        if php_lint_result.exit_code != 0:
            return f"{php_lint_result.stdout}\n{php_lint_result.stderr}"
        return None

    async def run_tests(self, node: Node[BaseData]) -> str | None:
        composer_result = await run_tests(node.data.workspace.ctr)
        if composer_result.exit_code != 0:
            return f"{composer_result.stdout}\n{composer_result.stderr}"
        return None

    async def run_migrations_checks(self, node: Node[BaseData]) -> str | None:
        # First, validate all migration files have correct syntax
        migration_errors = []
        
        # Check all files in the node's workspace for migrations
        for file_path, content in node.data.files.items():
            if "/migrations/" in file_path and file_path.endswith(".php") and content is not None:
                if not validate_migration_syntax(content):
                    migration_errors.append(
                        f"Invalid syntax in {file_path}: The opening brace after 'extends Migration' must be on a new line."
                    )
        
        # If there are syntax errors, return them without trying to run migrations
        if migration_errors:
            return "Migration syntax errors found:\n" + "\n".join(migration_errors)
        
        # If syntax is valid, run the migrations
        migrations_result = await run_migrations(node.data.workspace.client, node.data.workspace.ctr)
        if migrations_result.exit_code != 0:
            return f"{migrations_result.stdout}\n{migrations_result.stderr}"
        return None

    async def run_checks(self, node: Node[BaseData], user_prompt: str) -> str | None:
        await notify_stage(self.event_callback, "🔍 Running validation checks", "in_progress")

        all_errors = ""
        results = {}

        async with anyio.create_task_group() as tg:

            async def run_and_store(key, coro):
                """Helper to run a coroutine and store its result in the results dict."""
                try:
                    results[key] = await coro
                except Exception as e:
                    # Catch unexpected exceptions during check execution
                    logger.error(f"Error running check {key}: {e}")
                    results[key] = f"Internal error running check {key}: {e}"

            tg.start_soon(run_and_store, "ts_lint", self.run_ts_lint_checks(node))
            tg.start_soon(run_and_store, "php_lint", self.run_php_lint_checks(node))
            tg.start_soon(run_and_store, "ts_type_check", self.run_ts_type_checks(node))
            tg.start_soon(run_and_store, "tests", self.run_tests(node))
            tg.start_soon(run_and_store, "migrations", self.run_migrations_checks(node))

        if ts_lint_result := results.get("ts_lint"):
            logger.info(f"TypeScript lint checks failed: {ts_lint_result}")
            all_errors += f"TypeScript lint errors:\n{ts_lint_result}\n"
        if php_lint_result := results.get("php_lint"):
            logger.info(f"PHP lint checks failed: {php_lint_result[:200]}...")
            all_errors += f"{php_lint_result}\n"
        if ts_type_check_result := results.get("ts_type_check"):
            logger.info(f"TypeScript type checks failed: {ts_type_check_result}")
            all_errors += f"TypeScript type errors:\n{ts_type_check_result}\n"
        if tests_result := results.get("tests"):
            logger.info(f"Tests failed: {tests_result}")
            all_errors += f"Test errors:\n{tests_result}\n"
        if migrations_result := results.get("migrations"):
            logger.info(f"Migrations failed: {migrations_result}")
            all_errors += f"Migrations errors:\n{migrations_result}\n"

        if all_errors:
            await notify_stage(self.event_callback, "❌ Validation checks failed - fixing issues", "failed")
            errors = await self.compact_error_message(all_errors)
            return errors.strip()

        await notify_stage(self.event_callback, "✅ All validation checks passed", "completed")
        return None

    async def get_repo_files(
        self, workspace: Workspace, files: dict[str, str]
    ) -> list[str]:
        repo_files = set(files.keys())
        
        directories_to_check = []
        for allowed_path in self.files_allowed:
            clean_path = allowed_path.rstrip('/')
            if not clean_path.startswith('./'):
                clean_path = f"./{clean_path}"
            directories_to_check.append(clean_path)
        
        # Add any additional Laravel-specific directories that might exist
        # but aren't necessarily writable
        additional_dirs = [
            "./resources/js/Pages",  # Inertia.js convention (capital P)
            "./config",
            "./lang",
            "./public",
            "./storage/app"
        ]
        
        # Combine and deduplicate
        all_dirs = list(set(directories_to_check + additional_dirs))
        
        for dir_path in all_dirs:
            try:
                dir_files = await workspace.ls(dir_path)
                for file_path in dir_files:
                    # Remove leading ./ from dir_path if present
                    clean_dir = dir_path.lstrip("./")
                    repo_files.add(f"{clean_dir}/{file_path}")
            except FileNotFoundError:
                # Directory doesn't exist, skip it
                logger.debug(f"Directory {dir_path} not found, skipping")
                continue
            except Exception as e:
                logger.warning(f"Error listing directory {dir_path}: {e}")
                continue
                
        return sorted(list(repo_files))
    
    async def run_tools(
        self, node: Node[BaseData], user_prompt: str
    ) -> tuple[list[ToolUseResult], bool]:
        """Execute tools for a given node with Laravel-specific validation."""
        # First, call the parent implementation
        result, is_completed = await super().run_tools(node, user_prompt)
        
        # Then, check if any migration files were written/edited and validate them
        for i, block in enumerate(node.data.head().content):
            if isinstance(block, ToolUse) and block.name in ["write_file", "edit_file"]:
                path = block.input.get("path", "")  # pyright: ignore[reportAttributeAccessIssue]
                
                # Validate migration files
                if "/migrations/" in path and path.endswith(".php"):
                    # Find the corresponding result
                    tool_result = None
                    for j, res in enumerate(result):
                        if res.tool_use.id == block.id:
                            tool_result = res
                            break
                    
                    # If the operation was successful, validate the migration syntax
                    if tool_result and not tool_result.tool_result.is_error:
                        try:
                            # Read the current file content
                            file_content = await node.data.workspace.read_file(path)
                            if not validate_migration_syntax(file_content):
                                error_msg = (
                                    f"Invalid Laravel migration syntax in {path}. "
                                    "The opening brace after 'extends Migration' must be on a new line.\n\n"
                                    "Use this pattern:\n"
                                    f"{MIGRATION_SYNTAX_EXAMPLE}"
                                )
                                logger.warning(f"Migration validation failed for {path}")
                                # Replace the success result with an error
                                result[j] = ToolUseResult.from_tool_use(block, error_msg, is_error=True)
                                # Also remove the file from node.data.files if it was added
                                if path in node.data.files:
                                    del node.data.files[path]
                        except Exception as e:
                            logger.error(f"Error validating migration {path}: {e}")
                
        return result, is_completed
