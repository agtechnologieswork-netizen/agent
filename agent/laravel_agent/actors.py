import jinja2
import logging
import anyio
from typing import Callable, Awaitable
from core.base_node import Node
from core.workspace import Workspace
from core.actors import BaseData, FileOperationsActor, AgentSearchFailedException
from llm.common import AsyncLLM, Message, TextRaw, ToolUse, ToolUseResult
from laravel_agent import playbooks
from laravel_agent.utils import run_migrations, run_tests
from laravel_agent.playbooks import validate_migration_syntax, MIGRATION_SYNTAX_EXAMPLE
from core.notification_utils import notify_if_callback, notify_stage

logger = logging.getLogger(__name__)


class LaravelActor(FileOperationsActor):
    root: Node[BaseData] | None = None

    def __init__(
        self,
        llm: AsyncLLM,
        workspace: Workspace,
        beam_width: int = 3,
        max_depth: int = 30,
        system_prompt: str = playbooks.APPLICATION_SYSTEM_PROMPT,
        files_protected: list[str] = None,
        files_allowed: list[str] = None,
        event_callback: Callable[[str], Awaitable[None]] | None = None,
        fast_llm: AsyncLLM | None = None,
    ):
        super().__init__(llm, workspace, beam_width, max_depth, fast_llm)
        self.system_prompt = system_prompt
        self.event_callback = event_callback
        
        # Protected paths are files/directories that should NOT be modified
        # Note: allowed paths take precedence over protected paths
        self.files_protected = files_protected or [
            # Core Laravel framework files
            "vendor/",
            "bootstrap/cache/",
            "bootstrap/app.php",
            "artisan",
            "composer.json",
            "composer.lock",
            "package.json",
            "package-lock.json",
            ".env",
            ".env.example",
            
            # Configuration files that shouldn't be modified
            "config/app.php",
            "config/database.php",
            "config/auth.php",
            "config/session.php",
            "config/cache.php",
            "config/queue.php",
            
            # Core application files
            "app/Providers/",
            "app/Http/Kernel.php",
            "app/Console/Kernel.php",
            "app/Exceptions/Handler.php",
            
            # Public assets that shouldn't be modified
            "public/index.php",
            "public/.htaccess",
            "public/robots.txt",
            
            # Storage (except app folder)
            "storage/framework/",
            "storage/logs/",
            
            # Build and config files
            "webpack.mix.js",
            "vite.config.js",
            "vite.config.ts",
            "resources/js/app.tsx",  # Contains import.meta.glob pattern
            "tailwind.config.js",
            "postcss.config.js",
            ".gitignore",
            ".gitattributes",
            
            # Docker and deployment
            "docker/",
            "Dockerfile",
            "docker-compose.yml",
            ".dockerignore",
            
            # Testing infrastructure
            "phpunit.xml",
            "tests/TestCase.php",
            "tests/CreatesApplication.php"
        ]
        self.files_allowed = files_allowed  or [
            # Core application directories
            "resources/js/pages/", 
            "resources/js/Pages/",  # Inertia.js convention
            "app/Http/Controllers/Auth/",
            "app/Http/Controllers/",
            "app/Models/",
            "app/Services/",
            "app/Repositories/",
            "app/Http/Requests/",
            "app/Http/Resources/",
            "app/Http/Middleware/",
            
            # Routes - but note that some routes files might be protected
            "routes/",
            
            # Database directories
            "database/migrations/",
            "database/seeders/",
            "database/factories/",
            
            # Frontend resources
            "resources/views/",
            "resources/js/components/",
            "resources/js/hooks/",
            "resources/js/lib/",
            "resources/js/types/",
            "resources/css/",
            
            # Localization
            "lang/",
            
            # Testing
            "tests/",  # Allow all test files including ArchTest.php
            "tests/Feature/",
            "tests/Unit/",
            
            # Public directories - these might have issues:
            # "storage/app/public/",  # Storage might have permission issues in Docker
            # "public/css/",          # Usually generated by build process
            # "public/js/",           # Usually generated by build process
            
            "public/images/",
            
            # Configuration files that CAN be modified
            "vite.config.ts",  # Agent needs to modify this to add new pages
        ]

    @property
    def additional_tools(self) -> list:
        """Additional Laravel-specific tools including Artisan make commands."""
        return [
            {
                "name": "artisan_make",
                "description": "Run Laravel Artisan make commands to generate boilerplate code",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "type": {
                            "type": "string",
                            "enum": [
                                "controller", "model", "migration", "seeder", "factory",
                                "request", "resource", "middleware", "provider", "command",
                                "event", "listener", "job", "mail", "notification", "observer",
                                "policy", "rule", "scope", "cast", "channel", "exception",
                                "test", "component", "view", "trait", "interface", "enum", "class"
                            ],
                            "description": "The type of file to create"
                        },
                        "name": {
                            "type": "string",
                            "description": "The name of the file/class to create"
                        },
                        "options": {
                            "type": "object",
                            "description": "Additional options for the make command",
                            "properties": {
                                "migration": {"type": "boolean", "description": "Create a migration file (for models)"},
                                "controller": {"type": "boolean", "description": "Create a controller (for models)"},
                                "factory": {"type": "boolean", "description": "Create a factory (for models)"},
                                "seed": {"type": "boolean", "description": "Create a seeder (for models)"},
                                "requests": {"type": "boolean", "description": "Create form requests (for models)"},
                                "resource": {"type": "boolean", "description": "Create a resource controller"},
                                "api": {"type": "boolean", "description": "Create an API controller"},
                                "invokable": {"type": "boolean", "description": "Create an invokable controller"},
                                "parent": {"type": "string", "description": "Parent model (for controllers)"},
                                "model": {"type": "string", "description": "Model name (for controllers, factories, etc.)"},
                                "guard": {"type": "string", "description": "Guard name (for policies)"},
                                "test": {"type": "boolean", "description": "Create a test file"},
                                "pest": {"type": "boolean", "description": "Create a Pest test"},
                                "unit": {"type": "boolean", "description": "Create a unit test (default is feature)"},
                                "force": {"type": "boolean", "description": "Overwrite existing file"}
                            }
                        }
                    },
                    "required": ["type", "name"]
                }
            },
            {
                "name": "artisan_make_migration",
                "description": "Create a new database migration file with specific table operations",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Migration name (e.g., 'create_users_table', 'add_email_to_users')"
                        },
                        "create": {
                            "type": "string",
                            "description": "The table to create"
                        },
                        "table": {
                            "type": "string",
                            "description": "The table to modify"
                        }
                    },
                    "required": ["name"]
                }
            },
            {
                "name": "artisan_migrate",
                "description": "Run database migrations",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "fresh": {"type": "boolean", "description": "Drop all tables and re-run all migrations"},
                        "seed": {"type": "boolean", "description": "Run seeders after migrations"},
                        "force": {"type": "boolean", "description": "Force run in production"}
                    }
                }
            }
        ]

    async def handle_custom_tool(
        self, tool_use: ToolUse, node: Node[BaseData]
    ) -> ToolUseResult:
        """Handle Laravel-specific custom tools."""
        try:
            if tool_use.name == "artisan_make":
                # Build the artisan make command
                make_type = tool_use.input.get("type")  # pyright: ignore[reportAttributeAccessIssue]
                name = tool_use.input.get("name")  # pyright: ignore[reportAttributeAccessIssue]
                options = tool_use.input.get("options", {})  # pyright: ignore[reportAttributeAccessIssue]
                
                # Map type to Laravel's make command format
                command = ["php", "artisan", f"make:{make_type}", name]
                
                # Add options as flags
                if make_type == "model":
                    if options.get("migration"):
                        command.append("-m")
                    if options.get("controller"):
                        command.append("-c")
                    if options.get("factory"):
                        command.append("-f")
                    if options.get("seed"):
                        command.append("-s")
                    if options.get("requests"):
                        command.append("-r")
                elif make_type == "controller":
                    if options.get("resource"):
                        command.append("--resource")
                    if options.get("api"):
                        command.append("--api")
                    if options.get("invokable"):
                        command.append("--invokable")
                    if parent := options.get("parent"):
                        command.extend(["--parent", parent])
                    if model := options.get("model"):
                        command.extend(["--model", model])
                elif make_type in ["factory", "seeder"]:
                    if model := options.get("model"):
                        command.extend(["--model", model])
                elif make_type == "test":
                    if options.get("unit"):
                        command.append("--unit")
                    if options.get("pest"):
                        command.append("--pest")
                elif make_type == "policy":
                    if model := options.get("model"):
                        command.extend(["--model", model])
                    if guard := options.get("guard"):
                        command.extend(["--guard", guard])
                
                # Add force flag if specified
                if options.get("force"):
                    command.append("--force")
                
                # Execute the command
                result = await node.data.workspace.exec(command)
                
                if result.exit_code == 0:
                    # Read the generated file and add it to the workspace
                    # Parse the output to find the created file path
                    output = result.stdout
                    if "created successfully" in output.lower():
                        # Extract file path from output and read it
                        # This varies by command, but typically Laravel outputs the path
                        return ToolUseResult.from_tool_use(tool_use, output)
                    return ToolUseResult.from_tool_use(tool_use, output)
                else:
                    error_msg = f"Artisan make command failed: {result.stderr or result.stdout}"
                    return ToolUseResult.from_tool_use(tool_use, error_msg, is_error=True)
                    
            elif tool_use.name == "artisan_make_migration":
                name = tool_use.input.get("name")  # pyright: ignore[reportAttributeAccessIssue]
                command = ["php", "artisan", "make:migration", name]
                
                # Add table creation/modification flags
                if create_table := tool_use.input.get("create"):  # pyright: ignore[reportAttributeAccessIssue]
                    command.extend(["--create", create_table])
                elif table := tool_use.input.get("table"):  # pyright: ignore[reportAttributeAccessIssue]
                    command.extend(["--table", table])
                
                # Execute the command
                result = await node.data.workspace.exec(command)
                
                if result.exit_code == 0:
                    # After creating migration, read it and validate syntax
                    output = result.stdout
                    
                    # Find the migration file path from output
                    if "Created Migration:" in output:
                        # Extract the file path
                        lines = output.split('\n')
                        for line in lines:
                            if "database/migrations/" in line:
                                # Extract path and read the file
                                import re
                                match = re.search(r'(database/migrations/[\w_]+\.php)', line)
                                if match:
                                    migration_path = match.group(1)
                                    try:
                                        content = await node.data.workspace.read_file(migration_path)
                                        if not validate_migration_syntax(content):
                                            # Fix the syntax by ensuring proper formatting
                                            fixed_content = self._fix_migration_syntax(content)
                                            node.data.workspace.write_file(migration_path, fixed_content)
                                            node.data.files[migration_path] = fixed_content
                                            return ToolUseResult.from_tool_use(
                                                tool_use, 
                                                f"{output}\nNote: Fixed migration syntax to follow Laravel conventions."
                                            )
                                        else:
                                            node.data.files[migration_path] = content
                                    except Exception as e:
                                        logger.warning(f"Could not read/fix migration file: {e}")
                    
                    return ToolUseResult.from_tool_use(tool_use, output)
                else:
                    error_msg = f"Migration creation failed: {result.stderr or result.stdout}"
                    return ToolUseResult.from_tool_use(tool_use, error_msg, is_error=True)
                    
            elif tool_use.name == "artisan_migrate":
                command = ["php", "artisan", "migrate"]
                
                # Add migration options
                if tool_use.input.get("fresh"):  # pyright: ignore[reportAttributeAccessIssue]
                    command[2] = "migrate:fresh"  # Replace 'migrate' with 'migrate:fresh'
                if tool_use.input.get("seed"):  # pyright: ignore[reportAttributeAccessIssue]
                    command.append("--seed")
                if tool_use.input.get("force"):  # pyright: ignore[reportAttributeAccessIssue]
                    command.append("--force")
                
                # Execute the migration with postgres service
                result = await node.data.workspace.exec_with_pg(command)
                
                if result.exit_code == 0:
                    return ToolUseResult.from_tool_use(tool_use, result.stdout)
                else:
                    error_msg = f"Migration failed: {result.stderr or result.stdout}"
                    return ToolUseResult.from_tool_use(tool_use, error_msg, is_error=True)
            
            # If not a custom tool, call parent implementation
            return await super().handle_custom_tool(tool_use, node)
            
        except Exception as e:
            error_msg = f"Error executing {tool_use.name}: {str(e)}"
            logger.error(error_msg)
            return ToolUseResult.from_tool_use(tool_use, error_msg, is_error=True)

    def _fix_migration_syntax(self, content: str) -> str:
        """Fix migration syntax to ensure proper Laravel conventions."""
        import re
        # Ensure opening brace after 'extends Migration' is on a new line
        pattern = r'(extends\s+Migration)\s*{'
        replacement = r'\1\n{'
        return re.sub(pattern, replacement, content)

    async def execute(
        self,
        files: dict[str, str],
        user_prompt: str,
    ) -> Node[BaseData]:
        await notify_stage(self.event_callback, "🚀 Starting Laravel application generation", "in_progress")

        workspace = self.workspace.clone()
        logger.info(
            f"Start {self.__class__.__name__} execution with files: {files.keys()}"
        )
        for file_path, content in files.items():
            workspace.write_file(file_path, content)
        workspace.permissions(
            protected=self.files_protected, allowed=self.files_allowed
        )

        jinja_env = jinja2.Environment()
        user_prompt_template = jinja_env.from_string(playbooks.USER_PROMPT)
        repo_files = await self.get_repo_files(workspace, files)
        project_context = "\n".join(
            [
                "Project files:",
                *repo_files,
                "Writeable files and directories:",
                *[f"- {path}" for path in self.files_allowed],
            ]
        )
        user_prompt_rendered = user_prompt_template.render(
            project_context=project_context,
            user_prompt=user_prompt,
        )
        message = Message(role="user", content=[TextRaw(user_prompt_rendered)])
        self.root = Node(BaseData(workspace, [message], {}))

        solution: Node[BaseData] | None = None
        iteration = 0
        while solution is None:
            iteration += 1
            candidates = self.select(self.root)
            if not candidates:
                logger.error("No candidates to evaluate, search terminated")
                await notify_stage(self.event_callback, "❌ Laravel agent failed: No candidates to evaluate", "failed")
                raise AgentSearchFailedException(
                    agent_name="LaravelActor",
                    message="No candidates to evaluate, search terminated"
                )

            await notify_if_callback(self.event_callback, f"🔄 Working on implementation (iteration {iteration})...", "iteration progress")

            logger.info(
                f"Iteration {iteration}: Running LLM on {len(candidates)} candidates"
            )
            nodes = await self.run_llm(
                candidates,
                system_prompt=self.system_prompt,
                tools=self.tools,
                max_tokens=8192,
            )
            logger.info(f"Received {len(nodes)} nodes from LLM")

            for i, new_node in enumerate(nodes):
                logger.info(f"Evaluating node {i + 1}/{len(nodes)}")
                if await self.eval_node(new_node, user_prompt):
                    logger.info(f"Found solution at depth {new_node.depth}")
                    await notify_stage(self.event_callback, "✅ Laravel application generated successfully", "completed")
                    solution = new_node
                    break
        if solution is None:
            logger.error(f"{self.__class__.__name__} failed to find a solution")
            await notify_stage(self.event_callback, "❌ Laravel application generation failed", "failed")
            raise AgentSearchFailedException(
                agent_name="LaravelActor",
                message="Failed to find a solution after all iterations"
            )
        return solution

    def select(self, node: Node[BaseData]) -> list[Node[BaseData]]:
        candidates = []
        all_children = node.get_all_children()
        for n in all_children:
            if n.is_leaf and n.depth <= self.max_depth:
                if n.data.should_branch:
                    effective_beam_width = (
                        1 if len(all_children) > (n.depth + 1) else self.beam_width
                    )  # meaning we already branched once
                    logger.info(
                        f"Selecting candidates with effective beam width: {effective_beam_width}, current depth: {n.depth}/{self.max_depth}"
                    )
                    candidates.extend([n] * effective_beam_width)
                else:
                    candidates.append(n)
        logger.info(f"Selected {len(candidates)} leaf nodes for evaluation")
        return candidates

    async def run_ts_type_checks(self, node: Node[BaseData]) -> str | None:
        # CRITICAL: Ziggy-js causes typecheck to fail, agent fixes this but template has to be updated
        type_check_result = await node.data.workspace.exec(
            ["npm", "run", "types"]
        )
        if type_check_result.exit_code != 0:
            return f"{type_check_result.stdout}\n{type_check_result.stderr}"
        return None

    async def run_ts_lint_checks(self, node: Node[BaseData]) -> str | None:
        ts_lint_result = await node.data.workspace.exec(
            ["npm", "run", "lint"]
        )
        if ts_lint_result.exit_code != 0:
            return f"{ts_lint_result.stdout}\n{ts_lint_result.stderr}"
        return None

    async def run_php_lint_checks(self, node: Node[BaseData]) -> str | None:
        php_lint_result = await node.data.workspace.exec(
            ["composer", "lint"]
        )
        if php_lint_result.exit_code != 0:
            return f"{php_lint_result.stdout}\n{php_lint_result.stderr}"
        return None

    async def run_tests(self, node: Node[BaseData]) -> str | None:
        composer_result = await run_tests(node.data.workspace.ctr)
        if composer_result.exit_code != 0:
            return f"{composer_result.stdout}\n{composer_result.stderr}"
        return None

    async def run_migrations_checks(self, node: Node[BaseData]) -> str | None:
        # First, validate all migration files have correct syntax
        migration_errors = []
        
        # Check all files in the node's workspace for migrations
        for file_path, content in node.data.files.items():
            if "/migrations/" in file_path and file_path.endswith(".php") and content is not None:
                if not validate_migration_syntax(content):
                    migration_errors.append(
                        f"Invalid syntax in {file_path}: The opening brace after 'extends Migration' must be on a new line."
                    )
        
        # If there are syntax errors, return them without trying to run migrations
        if migration_errors:
            return "Migration syntax errors found:\n" + "\n".join(migration_errors)
        
        # If syntax is valid, run the migrations
        migrations_result = await run_migrations(node.data.workspace.client, node.data.workspace.ctr)
        if migrations_result.exit_code != 0:
            return f"{migrations_result.stdout}\n{migrations_result.stderr}"
        return None

    async def run_checks(self, node: Node[BaseData], user_prompt: str) -> str | None:
        await notify_stage(self.event_callback, "🔍 Running validation checks", "in_progress")

        all_errors = ""
        results = {}

        async with anyio.create_task_group() as tg:

            async def run_and_store(key, coro):
                """Helper to run a coroutine and store its result in the results dict."""
                try:
                    results[key] = await coro
                except Exception as e:
                    # Catch unexpected exceptions during check execution
                    logger.error(f"Error running check {key}: {e}")
                    results[key] = f"Internal error running check {key}: {e}"

            tg.start_soon(run_and_store, "ts_lint", self.run_ts_lint_checks(node))
            tg.start_soon(run_and_store, "php_lint", self.run_php_lint_checks(node))
            tg.start_soon(run_and_store, "ts_type_check", self.run_ts_type_checks(node))
            tg.start_soon(run_and_store, "tests", self.run_tests(node))
            tg.start_soon(run_and_store, "migrations", self.run_migrations_checks(node))

        if ts_lint_result := results.get("ts_lint"):
            logger.info(f"TypeScript lint checks failed: {ts_lint_result}")
            all_errors += f"TypeScript lint errors:\n{ts_lint_result}\n"
        if php_lint_result := results.get("php_lint"):
            logger.info(f"PHP lint checks failed: {php_lint_result[:200]}...")
            all_errors += f"{php_lint_result}\n"
        if ts_type_check_result := results.get("ts_type_check"):
            logger.info(f"TypeScript type checks failed: {ts_type_check_result}")
            all_errors += f"TypeScript type errors:\n{ts_type_check_result}\n"
        if tests_result := results.get("tests"):
            logger.info(f"Tests failed: {tests_result}")
            all_errors += f"Test errors:\n{tests_result}\n"
        if migrations_result := results.get("migrations"):
            logger.info(f"Migrations failed: {migrations_result}")
            all_errors += f"Migrations errors:\n{migrations_result}\n"

        if all_errors:
            await notify_stage(self.event_callback, "❌ Validation checks failed - fixing issues", "failed")
            errors = await self.compact_error_message(all_errors)
            return errors.strip()

        await notify_stage(self.event_callback, "✅ All validation checks passed", "completed")
        return None

    async def get_repo_files(
        self, workspace: Workspace, files: dict[str, str]
    ) -> list[str]:
        repo_files = set(files.keys())
        
        directories_to_check = []
        for allowed_path in self.files_allowed:
            clean_path = allowed_path.rstrip('/')
            if not clean_path.startswith('./'):
                clean_path = f"./{clean_path}"
            directories_to_check.append(clean_path)
        
        # Add any additional Laravel-specific directories that might exist
        # but aren't necessarily writable
        additional_dirs = [
            "./resources/js/Pages",  # Inertia.js convention (capital P)
            "./config",
            "./lang",
            "./public",
            "./storage/app"
        ]
        
        # Combine and deduplicate
        all_dirs = list(set(directories_to_check + additional_dirs))
        
        for dir_path in all_dirs:
            try:
                dir_files = await workspace.ls(dir_path)
                for file_path in dir_files:
                    # Remove leading ./ from dir_path if present
                    clean_dir = dir_path.lstrip("./")
                    repo_files.add(f"{clean_dir}/{file_path}")
            except FileNotFoundError:
                # Directory doesn't exist, skip it
                logger.debug(f"Directory {dir_path} not found, skipping")
                continue
            except Exception as e:
                logger.warning(f"Error listing directory {dir_path}: {e}")
                continue
                
        return sorted(list(repo_files))
    
    async def run_tools(
        self, node: Node[BaseData], user_prompt: str
    ) -> tuple[list[ToolUseResult], bool]:
        """Execute tools for a given node with Laravel-specific validation."""
        # First, call the parent implementation
        result, is_completed = await super().run_tools(node, user_prompt)
        
        # Then, check if any migration files were written/edited and validate them
        for i, block in enumerate(node.data.head().content):
            if isinstance(block, ToolUse) and block.name in ["write_file", "edit_file"]:
                path = block.input.get("path", "")  # pyright: ignore[reportAttributeAccessIssue]
                
                # Validate migration files
                if "/migrations/" in path and path.endswith(".php"):
                    # Find the corresponding result
                    tool_result = None
                    for j, res in enumerate(result):
                        if res.tool_use.id == block.id:
                            tool_result = res
                            break
                    
                    # If the operation was successful, validate the migration syntax
                    if tool_result and not tool_result.tool_result.is_error:
                        try:
                            # Read the current file content
                            file_content = await node.data.workspace.read_file(path)
                            if not validate_migration_syntax(file_content):
                                error_msg = (
                                    f"Invalid Laravel migration syntax in {path}. "
                                    "The opening brace after 'extends Migration' must be on a new line.\n\n"
                                    "Use this pattern:\n"
                                    f"{MIGRATION_SYNTAX_EXAMPLE}"
                                )
                                logger.warning(f"Migration validation failed for {path}")
                                # Replace the success result with an error
                                result[j] = ToolUseResult.from_tool_use(block, error_msg, is_error=True)
                                # Also remove the file from node.data.files if it was added
                                if path in node.data.files:
                                    del node.data.files[path]
                        except Exception as e:
                            logger.error(f"Error validating migration {path}: {e}")
                
        return result, is_completed
