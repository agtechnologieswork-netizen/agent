import asyncio
import json
import logging
from typing import Dict, List, Any, AsyncGenerator, Optional
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from starlette.concurrency import run_in_threadpool
from langfuse import Langfuse

from api.fsm_tools import FSMToolProcessor, run_with_claude
from api.fsm_api import FSMManager
from compiler.core import Compiler
from fsm_core.llm_common import get_sync_client

from anthropic.types import Message

from .models import (
    AgentRequest,
    AgentSseEvent,
    AgentMessage,
    UserMessage,
    ConversationMessage,
    AgentStatus,
    MessageKind,
    ErrorResponse
)

logger = logging.getLogger(__name__)

# Global state tracking for active agents
active_agents: Dict[str, Dict[str, Any]] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Initializing Agent Server API")
    yield

    logger.info("Shutting down Agent Server API")


app = FastAPI(
    title="Agent Server API",
    description="API for communication between the Platform (Backend) and the Agent Server",
    version="1.0.0",
    lifespan=lifespan
)


class AgentSession:
    """Manages a single agent session and its state machine"""

    def __init__(self, chatbot_id: str, trace_id: str, settings: Optional[Dict[str, Any]] = None):
        """Initialize a new agent session"""
        self.chatbot_id = chatbot_id
        self.trace_id = trace_id
        self.settings = settings or {}
        self.is_running = False
        self.is_complete = False
        self.fsm_instance = None
        self.processor_instance = None
        self.langfuse_client = Langfuse()
        self.langfuse_trace = self.langfuse_client.trace(
            id=trace_id,
            name="agent_server",
            user_id=chatbot_id,
            metadata={"agent_controlled": True},
        )
        self.llm_client = get_sync_client()
        self.compiler = Compiler("botbuild/tsp_compiler", "botbuild/app_schema")
        self._initialize_app()


    def _initialize_app(self):
        """Initialize the application instance"""
        logger.info(f"Initializing application for trace {self.trace_id}")
        self.fsm_api = FSMManager()
        self.processor_instance = FSMToolProcessor(self.fsm_api)
        self.messages = []
        logger.info(f"Application initialized for trace {self.trace_id}")


    @staticmethod
    def reconstruct_dialogue(input_messages: List[ConversationMessage]):
        messages = [{
            "role": "user" if msg.role == "user" else "assistant",
            "content": msg.content
        }
            for msg in input_messages]
        return messages


    def initialize_fsm(self, messages: List[ConversationMessage], agent_state: Optional[Dict[str, Any]] = None):
        """Initialize the FSM with messages and optional state"""
        logger.info(f"Initializing FSM for trace {self.trace_id}")
        logger.debug(f"Agent state present: {agent_state is not None}")

        if agent_state:
            logger.info(f"Setting external state for trace {self.trace_id}")
            self.fsm_api.set_full_external_state(agent_state)

        # Extract user messages from the conversation history
        initial_prompt = """You are a software engineering expert who can generate application code using a code generation framework. This framework uses a Finite State Machine (FSM) to guide the generation process.

Your task is to control the FSM through the following stages of code generation:
1. TypeSpec schema (API specification)
2. Drizzle schema (database models)
3. TypeScript types and interfaces
4. Handler test files
5. Handler implementation files

To successfully complete this task, follow these steps:

1. Start a new FSM session using the start_fsm tool.
2. For each component generated by the FSM:
   a. Carefully review the output.
   b. Decide whether to confirm the output or provide feedback for improvement.
   c. Use the appropriate tool (confirm_state or provide_feedback) based on your decision.
3. Repeat step 2 until all components have been generated and confirmed.
4. Use the complete_fsm tool to finalize the process and retrieve all artifacts.

During your review process, consider the following questions:
- Does the code correctly implement the application requirements?
- Are there any errors or inconsistencies?
- Could anything be improved or clarified?
- Does it match other requirements mentioned in the dialogue?

When providing feedback, be specific and actionable. If you're unsure about any aspect, ask for clarification before proceeding.
Do not ask too technical questions unless absolutely necessary. Instead, focus on the user requirements and delegate technical details to the FSM.

Do not consider the work complete until all five components (TypeSpec schema, Drizzle schema, TypeScript types and interfaces, handler test files, and handler implementation files) have been generated and the complete_fsm tool has been called."""
        system_message = UserMessage(
            content=initial_prompt,
            role="user",
        )
        self.messages = self.reconstruct_dialogue([system_message] + messages)
        logger.info(f"Starting FSM for trace {self.trace_id}")
        return

    @property
    def user_answered(self) -> bool:
        """Check if the user has answered"""
        if not self.messages:
            return False
        last_message = self.messages[-1]
        if isinstance(last_message, dict):
            return last_message.get("role") == "user"
        logger.warning(f"Last message : {last_message}")
        return last_message.role == "user"

    @property
    def work_in_progress(self) -> bool:
        return self.processor_instance.work_in_progress.locked()

    def get_state(self) -> Dict[str, Any]:
        """Get the current FSM state"""
        try:
            logger.debug(f"Getting state for trace {self.trace_id}")
            return self.fsm_api.get_full_external_state()
        except Exception as e:
            logger.error(f"Error getting state for trace {self.trace_id}: {str(e)}")
            return {}

    def process_step(self) -> Optional[AgentSseEvent]:
        """Process a single step and return an SSE event"""
        if not self.processor_instance:
            logger.warning(f"No processor instance found for trace {self.trace_id}")
            return None

        try:
            logger.info(f"Processing step for trace {self.trace_id}")
            new_message, is_complete, _ = run_with_claude(self.processor_instance, self.llm_client, self.messages)
            self.is_complete = is_complete
            logger.info(f"New message: {new_message}, is_complete: {is_complete}")
            if new_message:
                self.messages.append(new_message)
                status = AgentStatus.IDLE if (is_complete or not self.processor_instance.work_in_progress) else AgentStatus.RUNNING
                logger.info(f"Step completed for trace {self.trace_id}. Status: {status}")
                message_kind = MessageKind.STAGE_RESULT if status == AgentStatus.IDLE else MessageKind.FEEDBACK_RESPONSE

                return AgentSseEvent(
                    status=status,
                    trace_id=self.trace_id,
                    message=AgentMessage(
                        role="agent",
                        kind=message_kind,
                        content=new_message["content"],
                        agent_state=self.get_state(),
                        unified_diff=None
                    )
                )

            logger.info(f"No new message generated for trace {self.trace_id}")
            return None

        except Exception as e:
            logger.error(f"Error in process_step: {str(e)}")
            self.is_complete = True
            return AgentSseEvent(
                status=AgentStatus.IDLE,
                trace_id=self.trace_id,
                message=AgentMessage(
                    role="agent",
                    kind=MessageKind.RUNTIME_ERROR,
                    content=f"Error processing step: {str(e)}",
                    agent_state=None,
                    unified_diff=None
                )
            )


    def advance_fsm(self) -> bool:
        """
        Advance the FSM state. Returns True if more steps are needed,
        False if the FSM is complete or has reached a terminal state.
        """
        if self.is_complete:
            logger.info(f"FSM is already complete for trace {self.trace_id}")
            return False

        if not self.processor_instance:
            logger.warning(f"No processor instance found for trace {self.trace_id}")
            return False

        logger.info(f"FSM should continue for trace {self.trace_id}")
        return True


    def cleanup(self):
        """Cleanup resources for this session"""
        logger.info(f"Cleaning up resources for trace {self.trace_id}")
        self.processor_instance = None
        self.fsm_api = None
        self.messages = []
        logger.info(f"Resources cleaned up for trace {self.trace_id}")


async def get_agent_session(
    chatbot_id: str,
    trace_id: str,
    settings: Optional[Dict[str, Any]] = None
) -> AgentSession:
    """Get or create an agent session"""
    session_key = f"{chatbot_id}:{trace_id}"

    if session_key not in active_agents:
        logger.info(f"Creating new agent session for {session_key}")
        active_agents[session_key] = AgentSession(chatbot_id, trace_id, settings)

    return active_agents[session_key]

def _get_agent_state_by_messages(message: Dict[str, Any]) -> Dict[str, Any]:
    """
    Get the agent state from the messages and ensure all required fields are present.
    Pydantic validation requires the traceId field to be present in the JSON output.
    """
    result = message.copy()  # Create a copy to avoid modifying the original
    result["traceId"] = message.trace_id
    if isinstance(message.get("message", {}).get("agentState"), dict):
        if "message" not in result:
            result["message"] = {}
        if "agentState" not in result["message"]:
            result["message"]["agentState"] = {}
        for key, value in message["message"]["agentState"].items():
            if hasattr(value, "to_dict"):
                result["message"]["agentState"][key] = value.to_dict()
    return result

async def sse_event_generator(session: AgentSession, messages: List[ConversationMessage], agent_state: Optional[Dict[str, Any]] = None) -> AsyncGenerator[str, None]:
    """Generate SSE events for the agent session"""
    try:
        logger.info(f"Initializing FSM for trace {session.trace_id}")
        await run_in_threadpool(session.initialize_fsm, messages, agent_state)

        logger.info(f"Processing initial step for trace {session.trace_id}")
        initial_event = await run_in_threadpool(session.process_step)
        if initial_event:
            logger.info(f"Sending initial event for trace {session.trace_id}")
            event_dict = initial_event.dict(by_alias=True)
            agent_state = _get_agent_state_by_messages(event_dict)
            yield f"data: {json.dumps(agent_state)}\n\n"

        while True:
            logger.info(f"Checking if FSM should continue for trace {session.trace_id}")
            if not session.user_answered or session.work_in_progress:
                # sleep for a short duration to avoid busy waiting
                logger.info(f"User has not answered, waiting for user input for trace {session.trace_id}")
                await asyncio.sleep(0.1)
            else:
                logger.warning(f"Not sleeping: user answer {session.user_answered}, work in progress {session.work_in_progress}")

            should_continue = await run_in_threadpool(session.advance_fsm)
            if not should_continue:
                logger.info(f"FSM complete, processing final step for trace {session.trace_id}")
                final_event = await run_in_threadpool(session.process_step)
                if final_event:
                    logger.info(f"Sending final event for trace {session.trace_id}")
                    event_dict = final_event.dict(by_alias=True)
                    agent_state = _get_agent_state_by_messages(event_dict)
                    yield f"data: {json.dumps(agent_state)}\n\n"
                break

            logger.info(f"Processing next step for trace {session.trace_id}")
            event = await run_in_threadpool(session.process_step)
            if event:
                logger.info(f"Sending event with status {event.status} for trace {session.trace_id}")
                event_dict = event.dict(by_alias=True)
                agent_state = _get_agent_state_by_messages(event_dict)
                yield f"data: {json.dumps(agent_state)}\n\n"

            if event and event.status == AgentStatus.IDLE:
                logger.info(f"Agent is idle, stopping event stream for trace {session.trace_id}")
                break

            await asyncio.sleep(0.1)

    except Exception as e:
        logger.error(f"Error in SSE generator: {str(e)}")
        error_event = AgentSseEvent(
            status=AgentStatus.IDLE,
            trace_id=session.trace_id,
            message=AgentMessage(
                role="agent",
                kind=MessageKind.RUNTIME_ERROR,
                content=f"Error processing request: {str(e)}",
                agent_state=None,
                unified_diff=None
            )
        )
        logger.error(f"Sending error event for trace {session.trace_id}")
        error_dict = error_event.dict(by_alias=True)
        yield f"data: {json.dumps(error_dict)}\n\n"
    finally:
        logger.info(f"Cleaning up session for trace {session.trace_id}")
        await run_in_threadpool(session.cleanup)


@app.post("/message", response_model=None)
async def message(request: AgentRequest) -> StreamingResponse:
    """
    Send a message to the agent and stream responses via SSE.

    The server responds with a stream of Server-Sent Events (SSE).
    Each event contains a JSON payload with status updates.
    """
    try:
        logger.info(f"Received message request for chatbot {request.chatbot_id}, trace {request.trace_id}")
        logger.debug(f"Request settings: {request.settings}")
        logger.debug(f"Number of messages: {len(request.all_messages)}")

        session = await get_agent_session(
            request.chatbot_id,
            request.trace_id,
            request.settings
        )

        logger.info(f"Starting SSE stream for chatbot {request.chatbot_id}, trace {request.trace_id}")
        return StreamingResponse(
            sse_event_generator(
                session,
                request.all_messages,
                request.agent_state
            ),
            media_type="text/event-stream"
        )
    except Exception as e:
        logger.error(f"Error processing message request: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error processing request: {str(e)}"
        )


@app.get("/healthcheck")
async def healthcheck():
    """Health check endpoint"""
    logger.debug("Health check requested")
    return {"status": "healthy"}
